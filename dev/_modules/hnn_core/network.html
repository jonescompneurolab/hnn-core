
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>hnn_core.network &#8212; hnn-core 0.5.1.dev0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../_static/documentation_options.js?v=215e94d7"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=fd10adb8"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/hnn_core/network';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.16.1';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://jonescompneurolab.github.io/hnn-core/dev/_static/versions.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = 'dev';
        DOCUMENTATION_OPTIONS.show_version_warning_banner =
            false;
        </script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="0.5.1.dev0" />

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-199741045-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-199741045-1');
</script>


  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class=" navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/hnn-medium.png" class="logo__image only-light" alt="hnn-core 0.5.1.dev0 documentation - Home"/>
    <img src="../../_static/hnn-medium.png" class="logo__image only-dark pst-js-only" alt="hnn-core 0.5.1.dev0 documentation - Home"/>
  
  
</a></div>
    
  </div>
  
  <div class=" navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../install.html">
    Install (Textbook)
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../auto_examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api.html">
    API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../whats_new.html">
    Whatâ€™s new?
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../contributing.html">
    Contributing
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://github.com/jonescompneurolab/hnn-core">
    GitHub (Code)
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://hnn.brown.edu/">
    HNN Frontpage
  </a>
</li>

            <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button"
                data-bs-toggle="dropdown" aria-expanded="false"
                aria-controls="pst-nav-more-links">
                    More
                </button>
                <ul id="pst-nav-more-links" class="dropdown-menu">
                    
<li class=" ">
  <a class="nav-link dropdown-item nav-external" href="https://jonescompneurolab.github.io/textbook/content/preface.html">
    HNN Textbook
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-external" href="https://pypi.org/project/hnn-core/">
    PyPI package
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-external" href="https://anaconda.org/jonescompneurolab/repo">
    Conda packages
  </a>
</li>

                </ul>
            </li>
            
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-2"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-2"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-2"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-2">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../install.html">
    Install (Textbook)
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../auto_examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api.html">
    API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../whats_new.html">
    Whatâ€™s new?
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../contributing.html">
    Contributing
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://github.com/jonescompneurolab/hnn-core">
    GitHub (Code)
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://hnn.brown.edu/">
    HNN Frontpage
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://jonescompneurolab.github.io/textbook/content/preface.html">
    HNN Textbook
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://pypi.org/project/hnn-core/">
    PyPI package
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://anaconda.org/jonescompneurolab/repo">
    Conda packages
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-3"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-3"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-3"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-3">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">hnn_core.network</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for hnn_core.network</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Network class.&quot;&quot;&quot;</span>

<span class="c1"># Authors: Mainak Jas &lt;mjas@mgh.harvard.edu&gt;</span>
<span class="c1">#          Sam Neymotin &lt;samnemo@gmail.com&gt;</span>
<span class="c1">#          Blake Caldwell &lt;blake_caldwell@brown.edu&gt;</span>
<span class="c1">#          Christopher Bailey &lt;cjb@cfin.au.dk&gt;</span>
<span class="c1">#          Nick Tolley &lt;nicholas_tolley@brown.edu&gt;</span>
<span class="c1">#          Ryan Thorpe &lt;ryan_thorpe@brown.edu&gt;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">it</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dict</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.cell_response</span><span class="w"> </span><span class="kn">import</span> <span class="n">read_spikes</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.drives</span><span class="w"> </span><span class="kn">import</span> <span class="n">_drive_cell_event_times</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.drives</span><span class="w"> </span><span class="kn">import</span> <span class="n">_get_target_properties</span><span class="p">,</span> <span class="n">_add_drives_from_params</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.drives</span><span class="w"> </span><span class="kn">import</span> <span class="n">_check_drive_parameter_values</span><span class="p">,</span> <span class="n">_check_poisson_rates</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.cells_default</span><span class="w"> </span><span class="kn">import</span> <span class="n">pyramidal</span><span class="p">,</span> <span class="n">basket</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.params</span><span class="w"> </span><span class="kn">import</span> <span class="n">_long_name</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.viz</span><span class="w"> </span><span class="kn">import</span> <span class="n">plot_cells</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.externals.mne</span><span class="w"> </span><span class="kn">import</span> <span class="n">_validate_type</span><span class="p">,</span> <span class="n">_check_option</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.extracellular</span><span class="w"> </span><span class="kn">import</span> <span class="n">ExtracellularArray</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.check</span><span class="w"> </span><span class="kn">import</span> <span class="n">_check_gids</span><span class="p">,</span> <span class="n">_gid_to_type</span><span class="p">,</span> <span class="n">_string_input_to_list</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.hnn_io</span><span class="w"> </span><span class="kn">import</span> <span class="n">write_network_configuration</span><span class="p">,</span> <span class="n">network_to_dict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.externals.mne</span><span class="w"> </span><span class="kn">import</span> <span class="n">copy_doc</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">_replace_dict_identifier</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_create_cell_coords</span><span class="p">(</span><span class="n">n_pyr_x</span><span class="p">,</span> <span class="n">n_pyr_y</span><span class="p">,</span> <span class="n">z_coord</span><span class="p">,</span> <span class="n">inplane_distance</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates coordinate grid and place cells in it.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_pyr_x : int</span>
<span class="sd">        The number of Pyramidal cells in x direction.</span>
<span class="sd">    n_pyr_y : int</span>
<span class="sd">        The number of Pyramidal cells in y direction.</span>
<span class="sd">    z_coord : float</span>
<span class="sd">        Expressed as a positive DEPTH of L2 relative to L5 pyramidal cell</span>
<span class="sd">        somas, where L5 is defined to lie at z==0. Interlaminar weight/delay</span>
<span class="sd">        calculations (lamtha) are not affected. The basket cells are</span>
<span class="sd">        arbitrarily placed slightly above (L5) and slightly below (L2) their</span>
<span class="sd">        respective pyramidal cell layers.</span>
<span class="sd">    inplane_distance : float</span>
<span class="sd">        The grid spacing of pyramidal cells (in um). Note that basket cells are</span>
<span class="sd">        placed in an uneven formation. Each one of them lies on a grid point</span>
<span class="sd">        together with a pyramidal cell, though (overlapping).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    layer_dict : dict of list of tuple (x, y, z)</span>
<span class="sd">        Dictionary containing coordinate positions of &#39;layers&#39;. After calling</span>
<span class="sd">        &#39;_create_cell_coords&#39;, user can create their &#39;Network.pos_dict&#39; by mapping</span>
<span class="sd">        &#39;origin&#39; and their celltypes onto the different layers in &#39;layer_dict&#39;. Keys are</span>
<span class="sd">        &#39;L2_bottom&#39;, &#39;L2_mid&#39;, &#39;L5_bottom&#39;, &#39;L5_mid&#39;, and &#39;origin&#39;.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Common positions are all located at origin.</span>
<span class="sd">    Sort of a hack because of redundancy.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_calc_pyramidal_coord</span><span class="p">(</span><span class="n">xxrange</span><span class="p">,</span> <span class="n">yyrange</span><span class="p">,</span> <span class="n">z_coord</span><span class="p">):</span>
        <span class="n">list_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos</span> <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">xxrange</span><span class="p">,</span> <span class="n">yyrange</span><span class="p">,</span> <span class="p">[</span><span class="n">z_coord</span><span class="p">])]</span>
        <span class="k">return</span> <span class="n">list_coords</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_calc_basket_coord</span><span class="p">(</span><span class="n">n_x</span><span class="p">,</span> <span class="n">n_y</span><span class="p">,</span> <span class="n">z_coord</span><span class="p">,</span> <span class="n">inplane_distance</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
        <span class="n">xzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">inplane_distance</span>
        <span class="n">xone</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">inplane_distance</span>
        <span class="c1"># split even and odd y vals</span>
        <span class="n">yeven</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">inplane_distance</span>
        <span class="n">yodd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">inplane_distance</span>
        <span class="c1"># create general list of x,y coords and sort it</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos</span> <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">xzero</span><span class="p">,</span> <span class="n">yeven</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span>
            <span class="n">pos</span> <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">xone</span><span class="p">,</span> <span class="n">yodd</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">coords_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pos</span><span class="p">:</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># append the z value for position</span>
        <span class="n">list_coords</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">pos_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span> <span class="o">*</span> <span class="n">z_coord</span><span class="p">)</span> <span class="k">for</span> <span class="n">pos_xy</span> <span class="ow">in</span> <span class="n">coords_sorted</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">list_coords</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_calc_origin</span><span class="p">(</span><span class="n">xxrange</span><span class="p">,</span> <span class="n">yyrange</span><span class="p">,</span> <span class="n">z_coord</span><span class="p">):</span>
        <span class="c1"># origin&#39;s z component isn&#39;t used in calculating distance functions.</span>
        <span class="c1"># will be used for adding external drives.</span>
        <span class="n">origin_x</span> <span class="o">=</span> <span class="n">xxrange</span><span class="p">[</span><span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">xxrange</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="n">origin_y</span> <span class="o">=</span> <span class="n">yyrange</span><span class="p">[</span><span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">yyrange</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="n">origin_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">z_coord</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="p">(</span><span class="n">origin_x</span><span class="p">,</span> <span class="n">origin_y</span><span class="p">,</span> <span class="n">origin_z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">origin</span>

    <span class="c1"># Calculate distances</span>
    <span class="n">xxrange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_pyr_x</span><span class="p">)</span> <span class="o">*</span> <span class="n">inplane_distance</span>
    <span class="n">yyrange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_pyr_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">inplane_distance</span>

    <span class="c1"># Create layer dictionary with anatomical layer positions</span>
    <span class="n">layer_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;L5_bottom&quot;</span><span class="p">:</span> <span class="n">_calc_pyramidal_coord</span><span class="p">(</span><span class="n">xxrange</span><span class="p">,</span> <span class="n">yyrange</span><span class="p">,</span> <span class="n">z_coord</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
        <span class="s2">&quot;L2_bottom&quot;</span><span class="p">:</span> <span class="n">_calc_pyramidal_coord</span><span class="p">(</span><span class="n">xxrange</span><span class="p">,</span> <span class="n">yyrange</span><span class="p">,</span> <span class="n">z_coord</span><span class="o">=</span><span class="n">z_coord</span><span class="p">),</span>
        <span class="s2">&quot;L5_mid&quot;</span><span class="p">:</span> <span class="n">_calc_basket_coord</span><span class="p">(</span>
            <span class="n">n_pyr_x</span><span class="p">,</span>
            <span class="n">n_pyr_y</span><span class="p">,</span>
            <span class="n">z_coord</span><span class="o">=</span><span class="n">z_coord</span><span class="p">,</span>
            <span class="n">inplane_distance</span><span class="o">=</span><span class="n">inplane_distance</span><span class="p">,</span>
            <span class="n">weight</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="s2">&quot;L2_mid&quot;</span><span class="p">:</span> <span class="n">_calc_basket_coord</span><span class="p">(</span>
            <span class="n">n_pyr_x</span><span class="p">,</span>
            <span class="n">n_pyr_y</span><span class="p">,</span>
            <span class="n">z_coord</span><span class="o">=</span><span class="n">z_coord</span><span class="p">,</span>
            <span class="n">inplane_distance</span><span class="o">=</span><span class="n">inplane_distance</span><span class="p">,</span>
            <span class="n">weight</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="s2">&quot;origin&quot;</span><span class="p">:</span> <span class="n">_calc_origin</span><span class="p">(</span><span class="n">xxrange</span><span class="p">,</span> <span class="n">yyrange</span><span class="p">,</span> <span class="n">z_coord</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">layer_dict</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_compare_lists</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compares lists for equality</span>

<span class="sd">    From https://stackoverflow.com/a/7829388</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># make a mutable copy</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">t</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="n">t</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_connection_probability</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">probability</span><span class="p">,</span> <span class="n">conn_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove/keep a random subset of connections.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    conn : Instance of _Connectivity object</span>
<span class="sd">        Object specifying the biophysical parameters and src target pairs</span>
<span class="sd">        of a specific connection class. Function modifies conn in place.</span>
<span class="sd">    probability : float</span>
<span class="sd">        Probability of connection between any src-target pair.</span>
<span class="sd">        Defaults to 1.0 producing an all-to-all pattern.</span>
<span class="sd">    conn_seed : int</span>
<span class="sd">        Optional initial seed for random number generator (default: None).</span>
<span class="sd">        Used to randomly remove connections when probability &lt; 1.0.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    num_srcs and num_targets are not updated after pruning connections.</span>
<span class="sd">    These variables are meant to describe the set of original connections</span>
<span class="sd">    before they are randomly removed.</span>

<span class="sd">    The probability attribute will store the most recent value passed to</span>
<span class="sd">    this function. As such, this number does not accurately describe the</span>
<span class="sd">    connections probability of the original set after successive calls.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Random number generator for random connection selection</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">conn_seed</span><span class="p">)</span>
    <span class="n">_validate_type</span><span class="p">(</span><span class="n">probability</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;probability&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">probability</span> <span class="o">&lt;=</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">probability</span> <span class="o">&gt;=</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;probability must be in the range (0,1)&quot;</span><span class="p">)</span>
    <span class="c1"># Flatten connections into a list of targets.</span>
    <span class="n">all_connections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">[</span><span class="n">target_src_pair</span> <span class="k">for</span> <span class="n">target_src_pair</span> <span class="ow">in</span> <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;gid_pairs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="p">)</span>
    <span class="n">n_connections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_connections</span><span class="p">)</span> <span class="o">*</span> <span class="n">probability</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Select a random subset of connections to retain.</span>
    <span class="n">new_connections</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
        <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_connections</span><span class="p">)),</span> <span class="n">n_connections</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">remove_srcs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">connection_idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">src_gid</span><span class="p">,</span> <span class="n">target_src_pair</span> <span class="ow">in</span> <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;gid_pairs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">target_new</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">target_gid</span> <span class="ow">in</span> <span class="n">target_src_pair</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">connection_idx</span> <span class="ow">in</span> <span class="n">new_connections</span><span class="p">:</span>
                <span class="n">target_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_gid</span><span class="p">)</span>
            <span class="n">connection_idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Update targets for src_gid</span>
        <span class="k">if</span> <span class="n">target_new</span><span class="p">:</span>
            <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;gid_pairs&quot;</span><span class="p">][</span><span class="n">src_gid</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_new</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">remove_srcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src_gid</span><span class="p">)</span>
    <span class="c1"># Remove src_gids with no targets</span>
    <span class="k">for</span> <span class="n">src_gid</span> <span class="ow">in</span> <span class="n">remove_srcs</span><span class="p">:</span>
        <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;gid_pairs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">src_gid</span><span class="p">)</span>


<div class="viewcode-block" id="pick_connection">
<a class="viewcode-back" href="../../generated/hnn_core.pick_connection.html#hnn_core.pick_connection">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">pick_connection</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">src_gids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_gids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">receptor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns indices of connections that match search parameters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    net : Instance of Network object</span>
<span class="sd">        The Network object</span>
<span class="sd">    src_gids : str | int | range | list of int | None</span>
<span class="sd">        Identifier for source cells. Passing str arguments</span>
<span class="sd">        (&#39;L2_pyramidal&#39;, &#39;L2_basket&#39;, &#39;L5_pyramidal&#39;, &#39;L5_basket&#39;) is</span>
<span class="sd">        equivalent to passing a list of gids for the relevant cell type.</span>
<span class="sd">        source - target connections are made in an all-to-all pattern.</span>
<span class="sd">    target_gids : str | int | range | list of int | None</span>
<span class="sd">        Identifier for targets of source cells. Passing str arguments</span>
<span class="sd">        (&#39;L2_pyramidal&#39;, &#39;L2_basket&#39;, &#39;L5_pyramidal&#39;, &#39;L5_basket&#39;) is</span>
<span class="sd">        equivalent to passing a list of gids for the relevant cell type.</span>
<span class="sd">        source - target connections are made in an all-to-all pattern.</span>
<span class="sd">    loc : str | list of str | None</span>
<span class="sd">        Location of synapse on target cell. Must be</span>
<span class="sd">        &#39;proximal&#39;, &#39;distal&#39;, or &#39;soma&#39;. Note that inhibitory synapses</span>
<span class="sd">        (receptor=&#39;gabaa&#39; or &#39;gabab&#39;) of L2 pyramidal neurons are only</span>
<span class="sd">        valid loc=&#39;soma&#39;.</span>
<span class="sd">    receptor : str | list of str | None</span>
<span class="sd">        Synaptic receptor of connection. Must be one of:</span>
<span class="sd">        &#39;ampa&#39;, &#39;nmda&#39;, &#39;gabaa&#39;, or &#39;gabab&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    conn_indices : list of int</span>
<span class="sd">        List of indices corresponding to items in net.connectivity.</span>
<span class="sd">        Connection indices are included if any of the provided parameter</span>
<span class="sd">        values are present in a connection.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Passing a list of values to a single parameter corresponds to a</span>
<span class="sd">    logical OR operation across indices. For example,</span>
<span class="sd">    loc=[&#39;distal&#39;, &#39;proximal&#39;] returns all connections that target</span>
<span class="sd">    distal or proximal dendrites.</span>

<span class="sd">    Passing  multiple parameters corresponds to a logical AND operation.</span>
<span class="sd">    For example, net.pick_connection(loc=&#39;distal&#39;, receptor=&#39;ampa&#39;)</span>
<span class="sd">    returns only the indices of connections that target the distal</span>
<span class="sd">    dendrites and have ampa receptors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Convert src and target gids to lists</span>
    <span class="n">valid_srcs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">gid_ranges</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>  <span class="c1"># includes drives as srcs</span>
    <span class="n">valid_targets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">cell_types</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">src_gids_checked</span> <span class="o">=</span> <span class="n">_check_gids</span><span class="p">(</span>
        <span class="n">src_gids</span><span class="p">,</span> <span class="n">net</span><span class="o">.</span><span class="n">gid_ranges</span><span class="p">,</span> <span class="n">valid_srcs</span><span class="p">,</span> <span class="s2">&quot;src_gids&quot;</span><span class="p">,</span> <span class="n">same_type</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">target_gids_checked</span> <span class="o">=</span> <span class="n">_check_gids</span><span class="p">(</span>
        <span class="n">target_gids</span><span class="p">,</span> <span class="n">net</span><span class="o">.</span><span class="n">gid_ranges</span><span class="p">,</span> <span class="n">valid_targets</span><span class="p">,</span> <span class="s2">&quot;target_gids&quot;</span><span class="p">,</span> <span class="n">same_type</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>

    <span class="n">_validate_type</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="s2">&quot;loc&quot;</span><span class="p">,</span> <span class="s2">&quot;str, list, or None&quot;</span><span class="p">)</span>
    <span class="n">_validate_type</span><span class="p">(</span><span class="n">receptor</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="s2">&quot;receptor&quot;</span><span class="p">,</span> <span class="s2">&quot;str, list, or None&quot;</span><span class="p">)</span>

    <span class="n">valid_loc</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;proximal&quot;</span><span class="p">,</span> <span class="s2">&quot;distal&quot;</span><span class="p">,</span> <span class="s2">&quot;soma&quot;</span><span class="p">]</span>
    <span class="n">valid_receptor</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ampa&quot;</span><span class="p">,</span> <span class="s2">&quot;nmda&quot;</span><span class="p">,</span> <span class="s2">&quot;gabaa&quot;</span><span class="p">,</span> <span class="s2">&quot;gabab&quot;</span><span class="p">]</span>

    <span class="c1"># Convert receptor and loc to list</span>
    <span class="n">loc_list</span> <span class="o">=</span> <span class="n">_string_input_to_list</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">valid_loc</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">)</span>
    <span class="n">receptor_list</span> <span class="o">=</span> <span class="n">_string_input_to_list</span><span class="p">(</span><span class="n">receptor</span><span class="p">,</span> <span class="n">valid_receptor</span><span class="p">,</span> <span class="s2">&quot;receptor&quot;</span><span class="p">)</span>

    <span class="c1"># Create lookup dictionaries</span>
    <span class="n">src_dict</span><span class="p">,</span> <span class="n">target_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">),</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">loc_dict</span><span class="p">,</span> <span class="n">receptor_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">),</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">conn_idx</span><span class="p">,</span> <span class="n">conn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">connectivity</span><span class="p">):</span>
        <span class="c1"># Store connections matching each src_gid</span>
        <span class="k">for</span> <span class="n">src_gid</span> <span class="ow">in</span> <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;src_gids&quot;</span><span class="p">]:</span>
            <span class="n">src_dict</span><span class="p">[</span><span class="n">src_gid</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conn_idx</span><span class="p">)</span>

        <span class="c1"># Store connections matching each target_gid</span>
        <span class="k">for</span> <span class="n">target_gid</span> <span class="ow">in</span> <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;target_gids&quot;</span><span class="p">]:</span>
            <span class="n">target_dict</span><span class="p">[</span><span class="n">target_gid</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conn_idx</span><span class="p">)</span>

        <span class="c1"># Store connections matching each location</span>
        <span class="n">loc_dict</span><span class="p">[</span><span class="n">conn</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conn_idx</span><span class="p">)</span>

        <span class="c1"># Store connections matching each receptor</span>
        <span class="n">receptor_dict</span><span class="p">[</span><span class="n">conn</span><span class="p">[</span><span class="s2">&quot;receptor&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conn_idx</span><span class="p">)</span>

    <span class="c1"># Look up conn indices that match search terms and add to set.</span>
    <span class="n">conn_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">search_pairs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">src_gids_checked</span><span class="p">,</span> <span class="n">src_dict</span><span class="p">),</span>
        <span class="p">(</span><span class="n">target_gids_checked</span><span class="p">,</span> <span class="n">target_dict</span><span class="p">),</span>
        <span class="p">(</span><span class="n">loc_list</span><span class="p">,</span> <span class="n">loc_dict</span><span class="p">),</span>
        <span class="p">(</span><span class="n">receptor_list</span><span class="p">,</span> <span class="n">receptor_dict</span><span class="p">),</span>
    <span class="p">]</span>
    <span class="k">for</span> <span class="n">search_terms</span><span class="p">,</span> <span class="n">search_dict</span> <span class="ow">in</span> <span class="n">search_pairs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">search_terms</span><span class="p">:</span>
            <span class="n">inner_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="c1"># Union of indices which match inputs for single parameter</span>
            <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">search_terms</span><span class="p">:</span>
                <span class="n">inner_set</span> <span class="o">=</span> <span class="n">inner_set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">search_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="nb">list</span><span class="p">()))</span>

            <span class="c1"># Empty search</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">inner_set</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">()</span>
            <span class="c1"># Initial search has results</span>
            <span class="k">elif</span> <span class="n">inner_set</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">conn_set</span><span class="p">:</span>
                <span class="n">conn_set</span> <span class="o">=</span> <span class="n">inner_set</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># Subsequent searches have results</span>
            <span class="k">elif</span> <span class="n">inner_set</span> <span class="ow">and</span> <span class="n">conn_set</span><span class="p">:</span>
                <span class="c1"># Intersect across parameters</span>
                <span class="n">conn_set</span> <span class="o">=</span> <span class="n">conn_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">inner_set</span><span class="p">)</span>
                <span class="c1"># If at any point there&#39;s no matching elements, return empty</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">conn_set</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">list</span><span class="p">()</span>

    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">conn_set</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_get_cell_index_by_synapse_type</span><span class="p">(</span><span class="n">net</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the indices of excitatory and inhibitory cells in the Network.</span>

<span class="sd">    This function extracts the source GIDs (cell ID) of excitatory and inhibitory cells</span>
<span class="sd">    based on their connection types. Excitatory and inhibitory cells are identified by</span>
<span class="sd">    their electrophysiological metadata values. This does *not* return GIDs of external</span>
<span class="sd">    drives.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    net : Instance of Network object</span>
<span class="sd">        The Network object</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    e_cell_gids : list</span>
<span class="sd">        The source GIDs of excitatory cells.</span>
<span class="sd">    i_cell_gids : list</span>
<span class="sd">        The source GIDs of inhibitory cells.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">e_cell_gids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">i_cell_gids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cell_type_name</span><span class="p">,</span> <span class="n">cell_data</span> <span class="ow">in</span> <span class="n">net</span><span class="o">.</span><span class="n">cell_types</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">cell_data</span><span class="p">[</span><span class="s2">&quot;cell_metadata&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;electro_type&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;excitatory&quot;</span><span class="p">:</span>
            <span class="n">e_cell_gids</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">gid_ranges</span><span class="p">[</span><span class="n">cell_type_name</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">cell_data</span><span class="p">[</span><span class="s2">&quot;cell_metadata&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;electro_type&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;inhibitory&quot;</span><span class="p">:</span>
            <span class="n">i_cell_gids</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">gid_ranges</span><span class="p">[</span><span class="n">cell_type_name</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">e_cell_gids</span><span class="p">,</span> <span class="n">i_cell_gids</span>


<div class="viewcode-block" id="Network">
<a class="viewcode-back" href="../../generated/hnn_core.Network.html#hnn_core.Network">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Network</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The Network class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    params : dict</span>
<span class="sd">        The parameters to use for constructing the network.</span>
<span class="sd">    add_drives_from_params : bool, default=False</span>
<span class="sd">        If True, add drives as defined in the params-dict. NB this is mainly</span>
<span class="sd">        for backward-compatibility with HNN GUI, and will be deprecated in a</span>
<span class="sd">        future release.</span>
<span class="sd">    legacy_mode : bool, default=False</span>
<span class="sd">        Set to True by default to enable matching HNN GUI output when drives</span>
<span class="sd">        are added suitably. Will be deprecated in a future release.</span>
<span class="sd">    mesh_shape : tuple of int (default: (10, 10))</span>
<span class="sd">        Defines the (n_x, n_y) shape of the grid of pyramidal cells.</span>
<span class="sd">    pos_dict : dict of list of tuple (x, y, z), optional</span>
<span class="sd">        Dictionary containing the coordinate positions of all cells.</span>
<span class="sd">        Keys are &#39;L2_pyramidal&#39;, &#39;L5_pyramidal&#39;, &#39;L2_basket&#39;, &#39;L5_basket&#39;,</span>
<span class="sd">        or any external drive name.</span>
<span class="sd">    cell_types : dict of dict of (Cell | dict), optional</span>
<span class="sd">        Dictionary containing names of real cell types in the network (e.g. &#39;L2_basket&#39;)</span>
<span class="sd">        as keys and child-dictionaries describing the cell type. The child-dictionary</span>
<span class="sd">        contains two keys: &quot;cell_object&quot; and &quot;cell_metadata&quot;. The value of &quot;cell_object&quot;</span>
<span class="sd">        is the corresponding Cell instance of the cell type being described, and this</span>
<span class="sd">        instance is used as a template for the other cells of its type in the</span>
<span class="sd">        population. The value of &quot;cell_metadata&quot; is a dictionary containing several</span>
<span class="sd">        key-values pairs that describe different aspects of the cell type, described</span>
<span class="sd">        below:</span>
<span class="sd">            - &quot;morpho_type&quot; : either &quot;basket&quot; or &quot;pyramidal&quot;</span>
<span class="sd">            - &quot;electro_type&quot; : either &quot;inhibitory&quot; or &quot;excitatory&quot;</span>
<span class="sd">            - &quot;layer&quot; : either &quot;2&quot; or &quot;5&quot;</span>
<span class="sd">            - &quot;measure_dipole&quot; : either True or False</span>
<span class="sd">            - &quot;reference&quot;: optional</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    cell_types : dict of dict of (Cell | dict)</span>
<span class="sd">        Dictionary containing names of real cell types in the network (e.g. &#39;L2_basket&#39;)</span>
<span class="sd">        as keys and child-dictionaries describing the cell type. The child-dictionary</span>
<span class="sd">        contains two keys: &quot;cell_object&quot; and &quot;cell_metadata&quot;. The value of &quot;cell_object&quot;</span>
<span class="sd">        is the corresponding Cell instance of the cell type being described, and this</span>
<span class="sd">        instance is used as a template for the other cells of its type in the</span>
<span class="sd">        population. The value of &quot;cell_metadata&quot; is a dictionary containing several</span>
<span class="sd">        key-values pairs that describe different aspects of the cell type, described</span>
<span class="sd">        below:</span>
<span class="sd">            - &quot;morpho_type&quot; : either &quot;basket&quot; or &quot;pyramidal&quot;</span>
<span class="sd">            - &quot;electro_type&quot; : either &quot;inhibitory&quot; or &quot;excitatory&quot;</span>
<span class="sd">            - &quot;layer&quot; : either &quot;2&quot; or &quot;5&quot;</span>
<span class="sd">            - &quot;measure_dipole&quot; : either True or False</span>
<span class="sd">            - &quot;reference&quot;: optional</span>
<span class="sd">    gid_ranges : dict</span>
<span class="sd">        A dictionary of unique identifiers of each real and artificial cell</span>
<span class="sd">        in the network. Every cell type is represented by a key read from</span>
<span class="sd">        cell_types, followed by keys read from external_drives. The value</span>
<span class="sd">        of each key is a range of ints, one for each cell in given category.</span>
<span class="sd">        Examples: &#39;L2_basket&#39;: range(0, 270), &#39;evdist1&#39;: range(272, 542), etc</span>
<span class="sd">    pos_dict : dict of list of tuple (x, y, z)</span>
<span class="sd">        Dictionary containing the coordinate positions of all cells.</span>
<span class="sd">        Keys are &#39;L2_pyramidal&#39;, &#39;L5_pyramidal&#39;, &#39;L2_basket&#39;, &#39;L5_basket&#39;,</span>
<span class="sd">        or any external drive name.</span>
<span class="sd">    cell_response : CellResponse</span>
<span class="sd">        An instance of the CellResponse object.</span>
<span class="sd">    external_drives : dict (keys: drive names) of dict (keys: parameters)</span>
<span class="sd">        The external driving inputs to the network. Drives are added by</span>
<span class="sd">        defining their spike-time dynamics, and their connectivity to the real</span>
<span class="sd">        cells of the network. Event times are instantiated before simulation,</span>
<span class="sd">        and are stored under the ``&#39;events&#39;``-key (list of list; first</span>
<span class="sd">        index for trials, second for event time lists for each drive cell).</span>
<span class="sd">    external_biases : dict of dict (bias parameters for each cell type)</span>
<span class="sd">        The parameters of bias inputs to cell somata, e.g., tonic current clamp</span>
<span class="sd">    connectivity : list of dict</span>
<span class="sd">        List of dictionaries specifying each cell-cell and drive-cell</span>
<span class="sd">        connection</span>
<span class="sd">    rec_arrays : dict</span>
<span class="sd">        Stores electrode position information and voltages recorded by them</span>
<span class="sd">        for extracellular potential measurements. Multiple electrode arrays</span>
<span class="sd">        may be defined as unique keys. The values of the dictionary are</span>
<span class="sd">        instances of :class:`hnn_core.extracellular.ExtracellularArray`.</span>
<span class="sd">    threshold : float</span>
<span class="sd">        Firing threshold of all cells.</span>
<span class="sd">    delay : float</span>
<span class="sd">        Synaptic delay in ms.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ``net = jones_2009_model(params)`` is the recommended path for creating a</span>
<span class="sd">    network. Instantiating the network as ``net = Network(params)`` will</span>
<span class="sd">    produce a network with no cell-to-cell connections. As such,</span>
<span class="sd">    connectivity information contained in ``params`` will be ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">params</span><span class="p">,</span>
        <span class="n">add_drives_from_params</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">legacy_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">mesh_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
        <span class="n">pos_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cell_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Save the parameters used to create the Network</span>
        <span class="n">_validate_type</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="s2">&quot;params&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="c1"># Initialise a dictionary of cell ID&#39;s, which get used when the</span>
        <span class="c1"># network is constructed (&#39;built&#39;) in NetworkBuilder</span>
        <span class="c1"># We want it to remain in each Network object, so that the user can</span>
        <span class="c1"># interrogate a built and simulated net. In addition, CellResponse is</span>
        <span class="c1"># attached to a Network during simulation---Network is the natural</span>
        <span class="c1"># place to keep this information. Order matters: cell gids first, then</span>
        <span class="c1"># artificial drive cells</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gid_ranges</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_gids</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># utility: keep track of last GID</span>

        <span class="c1"># XXX this can be removed once tests are made independent of HNN GUI</span>
        <span class="c1"># creates nc_dict-entries for ALL cell types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_legacy_mode</span> <span class="o">=</span> <span class="n">legacy_mode</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_legacy_mode</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Legacy mode is used solely to maintain compatibility with&quot;</span>
                <span class="s2">&quot;.param files of the old HNN GUI. This feature will be &quot;</span>
                <span class="s2">&quot;deprecrated in future releases.&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cell_response</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># external drives and biases</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">external_drives</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">external_biases</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># network connectivity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="s2">&quot;threshold&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delay</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># extracellular recordings (if applicable)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rec_arrays</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># contents of pos_dict determines all downstream inferences of</span>
        <span class="c1"># cell counts, real and artificial</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_cells</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># used in tests and MPIBackend checks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># set the mesh shape</span>
        <span class="n">_validate_type</span><span class="p">(</span><span class="n">mesh_shape</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="s2">&quot;mesh_shape&quot;</span><span class="p">)</span>
        <span class="n">_validate_type</span><span class="p">(</span><span class="n">mesh_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;mesh_shape[0]&quot;</span><span class="p">)</span>
        <span class="n">_validate_type</span><span class="p">(</span><span class="n">mesh_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;mesh_shape[1]&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mesh_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">mesh_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;mesh_shape must be a tuple of positive integers, got: </span><span class="si">{</span><span class="n">mesh_shape</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_N_pyr_x</span> <span class="o">=</span> <span class="n">mesh_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_N_pyr_y</span> <span class="o">=</span> <span class="n">mesh_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_inplane_distance</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># XXX hard-coded default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layer_separation</span> <span class="o">=</span> <span class="mf">1307.4</span>  <span class="c1"># XXX hard-coded default</span>

        <span class="c1"># Handle positions and cell types</span>
        <span class="k">if</span> <span class="n">pos_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cell_types</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Use provided positions and cell types</span>
            <span class="n">_validate_type</span><span class="p">(</span><span class="n">pos_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="s2">&quot;pos_dict&quot;</span><span class="p">)</span>
            <span class="n">_validate_type</span><span class="p">(</span><span class="n">cell_types</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="s2">&quot;cell_types&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos_dict</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">pos_dict</span><span class="p">)</span>

            <span class="c1"># Add cell types from provided dictionary</span>
            <span class="k">for</span> <span class="n">cell_name</span><span class="p">,</span> <span class="n">cell_template</span> <span class="ow">in</span> <span class="n">cell_types</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">cell_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_dict</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_cell_type</span><span class="p">(</span>
                        <span class="n">cell_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_dict</span><span class="p">[</span><span class="n">cell_name</span><span class="p">],</span> <span class="n">cell_template</span><span class="o">=</span><span class="n">cell_template</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Default behavior - create standard network</span>
            <span class="n">cell_types_default</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;L2_basket&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;cell_object&quot;</span><span class="p">:</span> <span class="n">basket</span><span class="p">(</span><span class="n">cell_name</span><span class="o">=</span><span class="s2">&quot;L2_basket&quot;</span><span class="p">),</span>
                    <span class="s2">&quot;cell_metadata&quot;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s2">&quot;morpho_type&quot;</span><span class="p">:</span> <span class="s2">&quot;basket&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;electro_type&quot;</span><span class="p">:</span> <span class="s2">&quot;inhibitory&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;layer&quot;</span><span class="p">:</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;measure_dipole&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="s2">&quot;reference&quot;</span><span class="p">:</span> <span class="s2">&quot;https://doi.org/10.7554/eLife.51214&quot;</span><span class="p">,</span>
                    <span class="p">},</span>
                <span class="p">},</span>
                <span class="s2">&quot;L2_pyramidal&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;cell_object&quot;</span><span class="p">:</span> <span class="n">pyramidal</span><span class="p">(</span><span class="n">cell_name</span><span class="o">=</span><span class="s2">&quot;L2_pyramidal&quot;</span><span class="p">),</span>
                    <span class="s2">&quot;cell_metadata&quot;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s2">&quot;morpho_type&quot;</span><span class="p">:</span> <span class="s2">&quot;pyramidal&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;electro_type&quot;</span><span class="p">:</span> <span class="s2">&quot;excitatory&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;layer&quot;</span><span class="p">:</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;measure_dipole&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="s2">&quot;reference&quot;</span><span class="p">:</span> <span class="s2">&quot;https://doi.org/10.7554/eLife.51214&quot;</span><span class="p">,</span>
                    <span class="p">},</span>
                <span class="p">},</span>
                <span class="s2">&quot;L5_basket&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;cell_object&quot;</span><span class="p">:</span> <span class="n">basket</span><span class="p">(</span><span class="n">cell_name</span><span class="o">=</span><span class="s2">&quot;L5_basket&quot;</span><span class="p">),</span>
                    <span class="s2">&quot;cell_metadata&quot;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s2">&quot;morpho_type&quot;</span><span class="p">:</span> <span class="s2">&quot;basket&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;electro_type&quot;</span><span class="p">:</span> <span class="s2">&quot;inhibitory&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;layer&quot;</span><span class="p">:</span> <span class="s2">&quot;5&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;measure_dipole&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="s2">&quot;reference&quot;</span><span class="p">:</span> <span class="s2">&quot;https://doi.org/10.7554/eLife.51214&quot;</span><span class="p">,</span>
                    <span class="p">},</span>
                <span class="p">},</span>
                <span class="s2">&quot;L5_pyramidal&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;cell_object&quot;</span><span class="p">:</span> <span class="n">pyramidal</span><span class="p">(</span><span class="n">cell_name</span><span class="o">=</span><span class="s2">&quot;L5_pyramidal&quot;</span><span class="p">),</span>
                    <span class="s2">&quot;cell_metadata&quot;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s2">&quot;morpho_type&quot;</span><span class="p">:</span> <span class="s2">&quot;pyramidal&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;electro_type&quot;</span><span class="p">:</span> <span class="s2">&quot;excitatory&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;layer&quot;</span><span class="p">:</span> <span class="s2">&quot;5&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;measure_dipole&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="s2">&quot;reference&quot;</span><span class="p">:</span> <span class="s2">&quot;https://doi.org/10.7554/eLife.51214&quot;</span><span class="p">,</span>
                    <span class="p">},</span>
                <span class="p">},</span>
            <span class="p">}</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">set_cell_positions</span><span class="p">(</span>
                <span class="n">inplane_distance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_inplane_distance</span><span class="p">,</span>
                <span class="n">layer_separation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_layer_separation</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># populates self.gid_ranges for the 1st time: order matters for</span>
            <span class="c1"># NetworkBuilder!</span>
            <span class="k">for</span> <span class="n">cell_name</span><span class="p">,</span> <span class="n">cell_template</span> <span class="ow">in</span> <span class="n">cell_types_default</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_cell_type</span><span class="p">(</span>
                    <span class="n">cell_name</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pos_dict</span><span class="p">[</span><span class="n">cell_name</span><span class="p">],</span>
                    <span class="n">cell_template</span><span class="o">=</span><span class="n">cell_template</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">add_drives_from_params</span><span class="p">:</span>
            <span class="n">_add_drives_from_params</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_tstop</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Network.__repr__">
<a class="viewcode-back" href="../../generated/hnn_core.Network.html#hnn_core.Network.__repr__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="c1"># Dynamically create the description based on the current cell types</span>
        <span class="n">descriptions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="p">:</span>
            <span class="n">cell_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cell_name</span><span class="p">,</span> <span class="p">[]))</span>
            <span class="n">descriptions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cell_count</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">cell_name</span><span class="si">}</span><span class="s2"> cells&quot;</span><span class="p">)</span>

        <span class="c1"># Combine all descriptions into a single string</span>
        <span class="n">description_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">descriptions</span><span class="p">)</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="n">class_name</span><span class="si">}</span><span class="s2"> | </span><span class="si">{</span><span class="n">description_str</span><span class="si">}</span><span class="s2">&gt;&quot;</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Network</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="c1"># Check connectivity</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">connectivity</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">_compare_lists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Check all other attributes</span>
        <span class="n">attrs_to_ignore</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;connectivity&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs_to_ignore</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Does not have the same set of attributes</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="Network.set_cell_positions">
<a class="viewcode-back" href="../../generated/hnn_core.Network.html#hnn_core.Network.set_cell_positions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_cell_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">inplane_distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">layer_separation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set relative positions of cells arranged in a square grid</span>

<span class="sd">        Note that it is possible to change only a subset of the parameters</span>
<span class="sd">        (the default value of each is None, which implies no change).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inplane_distance : float</span>
<span class="sd">            The in plane-distance (in um) between pyramidal cell somas in the</span>
<span class="sd">            square grid. Note that this parameter does not affect the amplitude</span>
<span class="sd">            of the dipole moment.</span>
<span class="sd">        layer_separation : float</span>
<span class="sd">            The separation of pyramidal cell soma layers 2/3 and 5. Note that</span>
<span class="sd">            this parameter does not affect the amplitude of the dipole moment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplane_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inplane_distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inplane_distance</span>
        <span class="n">_validate_type</span><span class="p">(</span><span class="n">inplane_distance</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;inplane_distance&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplane_distance</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;In-plane distance must be positive, got: </span><span class="si">{</span><span class="n">inplane_distance</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">layer_separation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">layer_separation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layer_separation</span>
        <span class="n">_validate_type</span><span class="p">(</span><span class="n">layer_separation</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;layer_separation&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">layer_separation</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Layer separation must be positive, got: </span><span class="si">{</span><span class="n">layer_separation</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Get layer positions using layer dict</span>
        <span class="n">layer_dict</span> <span class="o">=</span> <span class="n">_create_cell_coords</span><span class="p">(</span>
            <span class="n">n_pyr_x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_N_pyr_x</span><span class="p">,</span>
            <span class="n">n_pyr_y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_N_pyr_y</span><span class="p">,</span>
            <span class="n">z_coord</span><span class="o">=</span><span class="n">layer_separation</span><span class="p">,</span>
            <span class="n">inplane_distance</span><span class="o">=</span><span class="n">inplane_distance</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Map layers to cell types, for default mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;L5_pyramidal&quot;</span><span class="p">:</span> <span class="n">layer_dict</span><span class="p">[</span><span class="s2">&quot;L5_bottom&quot;</span><span class="p">],</span>
            <span class="s2">&quot;L2_pyramidal&quot;</span><span class="p">:</span> <span class="n">layer_dict</span><span class="p">[</span><span class="s2">&quot;L2_bottom&quot;</span><span class="p">],</span>
            <span class="s2">&quot;L5_basket&quot;</span><span class="p">:</span> <span class="n">layer_dict</span><span class="p">[</span><span class="s2">&quot;L5_mid&quot;</span><span class="p">],</span>
            <span class="s2">&quot;L2_basket&quot;</span><span class="p">:</span> <span class="n">layer_dict</span><span class="p">[</span><span class="s2">&quot;L2_mid&quot;</span><span class="p">],</span>
            <span class="s2">&quot;origin&quot;</span><span class="p">:</span> <span class="n">layer_dict</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">],</span>
        <span class="p">}</span>

        <span class="c1"># update drives to be positioned at network origin</span>
        <span class="k">for</span> <span class="n">drive_name</span><span class="p">,</span> <span class="n">drive</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_drives</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_dict</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">]]</span> <span class="o">*</span> <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;n_drive_cells&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos_dict</span><span class="p">[</span><span class="n">drive_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_inplane_distance</span> <span class="o">=</span> <span class="n">inplane_distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layer_separation</span> <span class="o">=</span> <span class="n">layer_separation</span></div>


<div class="viewcode-block" id="Network.copy">
<a class="viewcode-back" href="../../generated/hnn_core.Network.html#hnn_core.Network.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a copy of the Network instance</span>

<span class="sd">        The returned copy retains the intrinsic connectivity between cells, as</span>
<span class="sd">        well as those of any external drives or biases added to the network.</span>
<span class="sd">        The parameters of drive dynamics are also retained, but the</span>
<span class="sd">        instantiated ``events`` of the drives are cleared. This allows</span>
<span class="sd">        iterating over the values defining drive dynamics, without the need to</span>
<span class="sd">        re-define connectivity. Extracellular recording arrays are retained in</span>
<span class="sd">        the network, but cleared of existing data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        net_copy : instance of Network</span>
<span class="sd">            A copy of the instance with previous simulation results and</span>
<span class="sd">            ``events`` of external drives removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">net_copy</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">net_copy</span><span class="o">.</span><span class="n">_reset_drives</span><span class="p">()</span>
        <span class="n">net_copy</span><span class="o">.</span><span class="n">_reset_rec_arrays</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">net_copy</span></div>


<div class="viewcode-block" id="Network.add_evoked_drive">
<a class="viewcode-back" href="../../generated/hnn_core.Network.html#hnn_core.Network.add_evoked_drive">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_evoked_drive</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">mu</span><span class="p">,</span>
        <span class="n">sigma</span><span class="p">,</span>
        <span class="n">numspikes</span><span class="p">,</span>
        <span class="n">location</span><span class="p">,</span>
        <span class="n">n_drive_cells</span><span class="o">=</span><span class="s2">&quot;n_cells&quot;</span><span class="p">,</span>
        <span class="n">cell_specific</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">weights_ampa</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">weights_nmda</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">space_constant</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>
        <span class="n">synaptic_delays</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">probability</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">event_seed</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">conn_seed</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add an &#39;evoked&#39; external drive to the network</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Unique name for the drive</span>
<span class="sd">        mu : float</span>
<span class="sd">            Mean of Gaussian event time distribution</span>
<span class="sd">        sigma : float</span>
<span class="sd">            Standard deviation of event time distribution</span>
<span class="sd">        numspikes : int</span>
<span class="sd">            Number of spikes at each target cell</span>
<span class="sd">        location : str</span>
<span class="sd">            Target location of synapses. Must be an element of</span>
<span class="sd">            `Cell.sect_loc` such as &#39;proximal&#39; or &#39;distal&#39;, which defines a</span>
<span class="sd">            group of sections, or an existing section such as &#39;soma&#39; or</span>
<span class="sd">            &#39;apical_tuft&#39; (defined in `Cell.sections` for all targeted cells).</span>
<span class="sd">            The parameter `legacy_mode` of the `Network` must be set to `False`</span>
<span class="sd">            to target specific sections.</span>
<span class="sd">        n_drive_cells : int | &#39;n_cells&#39;</span>
<span class="sd">            The number of drive cells that each contribute an independently</span>
<span class="sd">            sampled synaptic spike to the network according to the Gaussian</span>
<span class="sd">            time distribution (mu, sigma). If n_drive_cells=&#39;n_cells&#39;</span>
<span class="sd">            (default) and cell_specific=True, a drive cell gets assigned to</span>
<span class="sd">            each available simulated cell in the network with 1-to-1</span>
<span class="sd">            connectivity. Otherwise, drive cells are assigned with</span>
<span class="sd">            all-to-all connectivity. If you wish to synchronize the timing of</span>
<span class="sd">            this evoked drive across the network in a given trial with one</span>
<span class="sd">            spike, set n_drive_cells=1 and cell_specific=False.</span>
<span class="sd">        cell_specific : bool</span>
<span class="sd">            Whether each artificial drive cell has 1-to-1 (True, default) or</span>
<span class="sd">            all-to-all (False) connection parameters. Note that 1-to-1</span>
<span class="sd">            connectivity requires that n_drive_cells=&#39;n_cells&#39;, where &#39;n_cells&#39;</span>
<span class="sd">            denotes the number of all available cells that this drive can</span>
<span class="sd">            target in the network.</span>
<span class="sd">        weights_ampa : dict or None</span>
<span class="sd">            Synaptic weights (in uS) of AMPA receptors on each targeted cell</span>
<span class="sd">            type (dict keys). Cell types omitted from the dict are set to zero.</span>
<span class="sd">        weights_nmda : dict or None</span>
<span class="sd">            Synaptic weights (in uS) of NMDA receptors on each targeted cell</span>
<span class="sd">            type (dict keys). Cell types omitted from the dict are set to zero.</span>
<span class="sd">        synaptic_delays : dict or float</span>
<span class="sd">            Synaptic delay (in ms) at the column origin, dispersed laterally as</span>
<span class="sd">            a function of the space_constant. If float, applies to all target</span>
<span class="sd">            cell types. Use dict to create delay-&gt;cell mapping.</span>
<span class="sd">        space_constant : float</span>
<span class="sd">            Describes lateral dispersion (from the column origin) of synaptic</span>
<span class="sd">            weights and delays within the simulated column. The constant is</span>
<span class="sd">            measured in the units of ``inplane_distance`` of</span>
<span class="sd">            :class:`~hnn_core.Network`. For example, for ``space_constant=3``,</span>
<span class="sd">            the weights are modulated by the factor</span>
<span class="sd">            ``exp(-(x / (3 * inplane_distance)) ** 2)``, where x is the</span>
<span class="sd">            physical distance (in um) between the connected cells in the xy</span>
<span class="sd">            plane (delays are modulated by the inverse of this factor).</span>
<span class="sd">        probability : dict or float (default: 1.0)</span>
<span class="sd">            Probability of connection between any src-target pair.</span>
<span class="sd">            Use dict to create probability-&gt;cell mapping. If float, applies to</span>
<span class="sd">            all target cell types</span>
<span class="sd">        event_seed : int</span>
<span class="sd">            Optional initial seed for random number generator (default: 2).</span>
<span class="sd">            Used to generate event times for drive cells.</span>
<span class="sd">            Not fixed across trials (see Notes)</span>
<span class="sd">        conn_seed : int</span>
<span class="sd">            Optional initial seed for random number generator (default: 3).</span>
<span class="sd">            Used to randomly remove connections when probability &lt; 1.0.</span>
<span class="sd">            Fixed across trials (see Notes)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Random seeding behavior across trials is different for event_seed</span>
<span class="sd">        and conn_seed (n_trials &gt; 1 in simulate_dipole(..., n_trials):</span>

<span class="sd">        - event_seed</span>
<span class="sd">            Across trials, the random seed is incremented such that</span>
<span class="sd">            the exact spike times are different</span>
<span class="sd">        - conn_seed</span>
<span class="sd">            The random seed does not change across trials. This means for</span>
<span class="sd">            probability &lt; 1.0, the random subset of gids targeted is the same.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_legacy_mode</span><span class="p">:</span>
            <span class="n">_check_drive_parameter_values</span><span class="p">(</span><span class="s2">&quot;evoked&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">numspikes</span><span class="o">=</span><span class="n">numspikes</span><span class="p">)</span>
        <span class="n">drive</span> <span class="o">=</span> <span class="n">_NetworkDrive</span><span class="p">()</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;evoked&quot;</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">location</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;extgauss&quot;</span><span class="p">:</span>
            <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;gaussian&quot;</span>  <span class="c1"># XXX needed to pass legacy tests!</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;n_drive_cells&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_drive_cells</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;event_seed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">event_seed</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;conn_seed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">conn_seed</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;dynamics&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">numspikes</span><span class="o">=</span><span class="n">numspikes</span><span class="p">)</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;events&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="c1"># Need to save this information</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;weights_ampa&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights_ampa</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;weights_nmda&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights_nmda</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;synaptic_delays&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">synaptic_delays</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;probability&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">probability</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_attach_drive</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">drive</span><span class="p">,</span>
            <span class="n">weights_ampa</span><span class="p">,</span>
            <span class="n">weights_nmda</span><span class="p">,</span>
            <span class="n">location</span><span class="p">,</span>
            <span class="n">space_constant</span><span class="p">,</span>
            <span class="n">synaptic_delays</span><span class="p">,</span>
            <span class="n">n_drive_cells</span><span class="p">,</span>
            <span class="n">cell_specific</span><span class="p">,</span>
            <span class="n">probability</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Network.add_poisson_drive">
<a class="viewcode-back" href="../../generated/hnn_core.Network.html#hnn_core.Network.add_poisson_drive">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_poisson_drive</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">tstart</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">tstop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">rate_constant</span><span class="p">,</span>
        <span class="n">location</span><span class="p">,</span>
        <span class="n">n_drive_cells</span><span class="o">=</span><span class="s2">&quot;n_cells&quot;</span><span class="p">,</span>
        <span class="n">cell_specific</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">weights_ampa</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">weights_nmda</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">space_constant</span><span class="o">=</span><span class="mf">100.0</span><span class="p">,</span>
        <span class="n">synaptic_delays</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">probability</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">event_seed</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">conn_seed</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a Poisson-distributed external drive to the network</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Unique name for the drive</span>
<span class="sd">        tstart : float</span>
<span class="sd">            Start time of Poisson-distributed spike train (default: 0)</span>
<span class="sd">        tstop : float</span>
<span class="sd">            End time of the spike train (defaults to None: tstop is set to the</span>
<span class="sd">            end of the simulation)</span>
<span class="sd">        rate_constant : float or dict of floats</span>
<span class="sd">            Rate constant (lambda &gt; 0) of the renewal-process generating the</span>
<span class="sd">            samples. If a float is provided, the same rate constant is applied</span>
<span class="sd">            to each target cell type. Cell type-specific values may be</span>
<span class="sd">            provided as a dictionary, in which a key must be present for each</span>
<span class="sd">            cell type with non-zero AMPA or NMDA weights.</span>
<span class="sd">        location : str</span>
<span class="sd">            Target location of synapses. Must be an element of</span>
<span class="sd">            `Cell.sect_loc` such as &#39;proximal&#39; or &#39;distal&#39;, which defines a</span>
<span class="sd">            group of sections, or an existing section such as &#39;soma&#39; or</span>
<span class="sd">            &#39;apical_tuft&#39; (defined in `Cell.sections` for all targeted cells).</span>
<span class="sd">            The parameter `legacy_mode` of the `Network` must be set to `False`</span>
<span class="sd">            to target specific sections.</span>
<span class="sd">        n_drive_cells : int | &#39;n_cells&#39;</span>
<span class="sd">            The number of drive cells that each contribute an independently</span>
<span class="sd">            sampled synaptic spike to the network according to a Poisson</span>
<span class="sd">            process. If n_drive_cells=&#39;n_cells&#39; (default) and</span>
<span class="sd">            cell_specific=True, a drive cell gets assigned to each available</span>
<span class="sd">            simulated cell in the network with 1-to-1 connectivity. Otherwise,</span>
<span class="sd">            drive cells are assigned with all-to-all connectivity. If you wish</span>
<span class="sd">            to synchronize the timing of Poisson drive across the network in a</span>
<span class="sd">            given trial, set n_drive_cells=1 and cell_specific=False.</span>
<span class="sd">        cell_specific : bool</span>
<span class="sd">            Whether each artificial drive cell has 1-to-1 (True, default) or</span>
<span class="sd">            all-to-all (False) connection parameters. Note that 1-to-1</span>
<span class="sd">            connectivity requires that n_drive_cells=&#39;n_cells&#39;, where &#39;n_cells&#39;</span>
<span class="sd">            denotes the number of all available cells that this drive can</span>
<span class="sd">            target in the network.</span>
<span class="sd">        weights_ampa : dict or None</span>
<span class="sd">            Synaptic weights (in uS) of AMPA receptors on each targeted cell</span>
<span class="sd">            type (dict keys). Cell types omitted from the dict are set to zero.</span>
<span class="sd">        weights_nmda : dict or None</span>
<span class="sd">            Synaptic weights (in uS) of NMDA receptors on each targeted cell</span>
<span class="sd">            type (dict keys). Cell types omitted from the dict are set to zero.</span>
<span class="sd">        synaptic_delays : dict or float</span>
<span class="sd">            Synaptic delay (in ms) at the column origin, dispersed laterally as</span>
<span class="sd">            a function of the space_constant. If float, applies to all target</span>
<span class="sd">            cell types. Use dict to create delay-&gt;cell mapping.</span>
<span class="sd">        space_constant : float</span>
<span class="sd">            Describes lateral dispersion (from the column origin) of synaptic</span>
<span class="sd">            weights and delays within the simulated column. The constant is</span>
<span class="sd">            measured in the units of ``inplane_distance`` of</span>
<span class="sd">            :class:`~hnn_core.Network`. For example, for ``space_constant=3``,</span>
<span class="sd">            the weights and delays are modulated by the factor</span>
<span class="sd">            ``exp(-(x / (3 * inplane_distance)) ** 2)``, where ``x`` is the</span>
<span class="sd">            physical distance (in um) between the connected cells in the xy</span>
<span class="sd">            plane.</span>
<span class="sd">        probability : dict or float (default: 1.0)</span>
<span class="sd">            Probability of connection between any src-target pair.</span>
<span class="sd">            Use dict to create probability-&gt;cell mapping. If float, applies to</span>
<span class="sd">            all target cell types.</span>
<span class="sd">        event_seed : int</span>
<span class="sd">            Optional initial seed for random number generator (default: 2).</span>
<span class="sd">            Used to generate event times for drive cells.</span>
<span class="sd">        conn_seed : int</span>
<span class="sd">            Optional initial seed for random number generator (default: 3).</span>
<span class="sd">            Used to randomly remove connections when probability &lt; 1.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_check_drive_parameter_values</span><span class="p">(</span><span class="s2">&quot;Poisson&quot;</span><span class="p">,</span> <span class="n">tstart</span><span class="o">=</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="o">=</span><span class="n">tstop</span><span class="p">)</span>
        <span class="n">target_populations</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_get_target_properties</span><span class="p">(</span>
            <span class="n">weights_ampa</span><span class="p">,</span>
            <span class="n">weights_nmda</span><span class="p">,</span>
            <span class="n">synaptic_delays</span><span class="p">,</span>
            <span class="n">location</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="p">,</span>
            <span class="n">probability</span><span class="o">=</span><span class="n">probability</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">_check_poisson_rates</span><span class="p">(</span><span class="n">rate_constant</span><span class="p">,</span> <span class="n">target_populations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rate_constant</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cell_specific</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Drives specific to cell types are only &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;possible with cell_specific=True and &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;n_drive_cells=&#39;n_cells&#39;. Got cell_specific&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; cell_specific=</span><span class="si">{</span><span class="n">cell_specific</span><span class="si">}</span><span class="s2"> and &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;n_drive_cells=</span><span class="si">{</span><span class="n">n_drive_cells</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rate_constant</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">cell_specific</span><span class="p">:</span>
                <span class="n">rate_constant</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">cell_type</span><span class="p">:</span> <span class="n">rate_constant</span> <span class="k">for</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="n">target_populations</span>
                <span class="p">}</span>

        <span class="n">drive</span> <span class="o">=</span> <span class="n">_NetworkDrive</span><span class="p">()</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;poisson&quot;</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">location</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;n_drive_cells&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_drive_cells</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;event_seed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">event_seed</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;conn_seed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">conn_seed</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;dynamics&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">tstart</span><span class="o">=</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="o">=</span><span class="n">tstop</span><span class="p">,</span> <span class="n">rate_constant</span><span class="o">=</span><span class="n">rate_constant</span>
        <span class="p">)</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;events&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="c1"># Need to save this information</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;weights_ampa&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights_ampa</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;weights_nmda&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights_nmda</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;synaptic_delays&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">synaptic_delays</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;probability&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">probability</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_attach_drive</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">drive</span><span class="p">,</span>
            <span class="n">weights_ampa</span><span class="p">,</span>
            <span class="n">weights_nmda</span><span class="p">,</span>
            <span class="n">location</span><span class="p">,</span>
            <span class="n">space_constant</span><span class="p">,</span>
            <span class="n">synaptic_delays</span><span class="p">,</span>
            <span class="n">n_drive_cells</span><span class="p">,</span>
            <span class="n">cell_specific</span><span class="p">,</span>
            <span class="n">probability</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Network.add_bursty_drive">
<a class="viewcode-back" href="../../generated/hnn_core.Network.html#hnn_core.Network.add_bursty_drive">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_bursty_drive</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">tstart</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">tstart_std</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">tstop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">location</span><span class="p">,</span>
        <span class="n">burst_rate</span><span class="p">,</span>
        <span class="n">burst_std</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">numspikes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">spike_isi</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">n_drive_cells</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">cell_specific</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">weights_ampa</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">weights_nmda</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">synaptic_delays</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">space_constant</span><span class="o">=</span><span class="mf">100.0</span><span class="p">,</span>
        <span class="n">probability</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">event_seed</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">conn_seed</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a bursty (rhythmic) external drive to all cells of the network</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Unique name for the drive</span>
<span class="sd">        tstart : float</span>
<span class="sd">            Start time of the burst trains (default: 0)</span>
<span class="sd">        tstart_std : float</span>
<span class="sd">            If greater than 0, randomize start time with standard deviation</span>
<span class="sd">            tstart_std (unit: ms). Effectively jitters start time across</span>
<span class="sd">            multiple trials.</span>
<span class="sd">        tstop : float</span>
<span class="sd">            End time of burst trains (defaults to None: tstop is set to the</span>
<span class="sd">            end of the simulation)</span>
<span class="sd">        location : str</span>
<span class="sd">            Target location of synapses. Must be an element of</span>
<span class="sd">            `Cell.sect_loc` such as &#39;proximal&#39; or &#39;distal&#39;, which defines a</span>
<span class="sd">            group of sections, or an existing section such as &#39;soma&#39; or</span>
<span class="sd">            &#39;apical_tuft&#39; (defined in `Cell.sections` for all targeted cells).</span>
<span class="sd">            The parameter `legacy_mode` of the `Network` must be set to `False`</span>
<span class="sd">            to target specific sections.</span>
<span class="sd">        burst_rate : float</span>
<span class="sd">            The mean rate at which cyclic bursts occur (unit: Hz)</span>
<span class="sd">        burst_std : float</span>
<span class="sd">            The standard deviation of the burst occurrence on each cycle</span>
<span class="sd">            (unit: ms). Default: 0 ms</span>
<span class="sd">        numspikes : int</span>
<span class="sd">            The number of spikes in a burst. This is the spikes/burst parameter</span>
<span class="sd">            in the GUI. Default: 2 (doublet)</span>
<span class="sd">        spike_isi : float</span>
<span class="sd">            Time between spike events within a cycle (ISI). Default: 10 ms</span>
<span class="sd">        n_drive_cells : int | &#39;n_cells&#39;</span>
<span class="sd">            The number of drive cells that contribute an independently sampled</span>
<span class="sd">            burst at each cycle. If n_drive_cells=&#39;n_cells&#39; and</span>
<span class="sd">            cell_specific=True, a drive cell gets assigned to</span>
<span class="sd">            each available simulated cell in the network with 1-to-1</span>
<span class="sd">            connectivity. Otherwise (default: 1), drive cells are assigned with</span>
<span class="sd">            all-to-all connectivity and provide synchronous input to cells in</span>
<span class="sd">            the network.</span>
<span class="sd">        cell_specific : bool</span>
<span class="sd">            Whether each artificial drive cell has 1-to-1 (True) or all-to-all</span>
<span class="sd">            (False, default) connection parameters. Note that 1-to-1</span>
<span class="sd">            connectivity requires that n_drive_cells=&#39;n_cells&#39;, where &#39;n_cells&#39;</span>
<span class="sd">            denotes the number of all available cells that this drive can</span>
<span class="sd">            target in the network.</span>
<span class="sd">        weights_ampa : dict or None</span>
<span class="sd">            Synaptic weights (in uS) of AMPA receptors on each targeted cell</span>
<span class="sd">            type (dict keys). Cell types omitted from the dict are set to zero.</span>
<span class="sd">        weights_nmda : dict or None</span>
<span class="sd">            Synaptic weights (in uS) of NMDA receptors on each targeted cell</span>
<span class="sd">            type (dict keys). Cell types omitted from the dict are set to zero.</span>
<span class="sd">        synaptic_delays : dict or float</span>
<span class="sd">            Synaptic delay (in ms) at the column origin, dispersed laterally as</span>
<span class="sd">            a function of the space_constant. If float, applies to all target</span>
<span class="sd">            cell types. Use dict to create delay-&gt;cell mapping.</span>
<span class="sd">        space_constant : float</span>
<span class="sd">            Describes lateral dispersion (from the column origin) of synaptic</span>
<span class="sd">            weights and delays within the simulated column. The constant is</span>
<span class="sd">            measured in the units of ``inplane_distance`` of</span>
<span class="sd">            :class:`~hnn_core.Network`. For example, for ``space_constant=3``,</span>
<span class="sd">            the weights and delays are modulated by the factor</span>
<span class="sd">            ``exp(-(x / (3 * inplane_distance)) ** 2)``, where ``x`` is the</span>
<span class="sd">            physical distance (in um) between the connected cells in the xy</span>
<span class="sd">            plane.</span>
<span class="sd">        probability : dict or float (default: 1.0)</span>
<span class="sd">            Probability of connection between any src-target pair.</span>
<span class="sd">            Use dict to create probability-&gt;cell mapping. If float, applies to</span>
<span class="sd">            all target cell types.</span>
<span class="sd">        event_seed : int</span>
<span class="sd">            Optional initial seed for random number generator (default: 2).</span>
<span class="sd">            Used to generate event times for drive cells.</span>
<span class="sd">        conn_seed : int</span>
<span class="sd">            Optional initial seed for random number generator (default: 3).</span>
<span class="sd">            Used to randomly remove connections when probability &lt; 1.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_legacy_mode</span><span class="p">:</span>
            <span class="n">_check_drive_parameter_values</span><span class="p">(</span>
                <span class="s2">&quot;bursty&quot;</span><span class="p">,</span>
                <span class="n">tstart</span><span class="o">=</span><span class="n">tstart</span><span class="p">,</span>
                <span class="n">tstop</span><span class="o">=</span><span class="n">tstop</span><span class="p">,</span>
                <span class="n">sigma</span><span class="o">=</span><span class="n">tstart_std</span><span class="p">,</span>
                <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">_check_drive_parameter_values</span><span class="p">(</span>
                <span class="s2">&quot;bursty&quot;</span><span class="p">,</span>
                <span class="n">sigma</span><span class="o">=</span><span class="n">burst_std</span><span class="p">,</span>
                <span class="n">numspikes</span><span class="o">=</span><span class="n">numspikes</span><span class="p">,</span>
                <span class="n">spike_isi</span><span class="o">=</span><span class="n">spike_isi</span><span class="p">,</span>
                <span class="n">burst_rate</span><span class="o">=</span><span class="n">burst_rate</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">drive</span> <span class="o">=</span> <span class="n">_NetworkDrive</span><span class="p">()</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bursty&quot;</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">location</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;n_drive_cells&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_drive_cells</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;event_seed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">event_seed</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;conn_seed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">conn_seed</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;dynamics&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">tstart</span><span class="o">=</span><span class="n">tstart</span><span class="p">,</span>
            <span class="n">tstart_std</span><span class="o">=</span><span class="n">tstart_std</span><span class="p">,</span>
            <span class="n">tstop</span><span class="o">=</span><span class="n">tstop</span><span class="p">,</span>
            <span class="n">burst_rate</span><span class="o">=</span><span class="n">burst_rate</span><span class="p">,</span>
            <span class="n">burst_std</span><span class="o">=</span><span class="n">burst_std</span><span class="p">,</span>
            <span class="n">numspikes</span><span class="o">=</span><span class="n">numspikes</span><span class="p">,</span>
            <span class="n">spike_isi</span><span class="o">=</span><span class="n">spike_isi</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;events&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="c1"># Need to save this information</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;weights_ampa&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights_ampa</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;weights_nmda&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights_nmda</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;synaptic_delays&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">synaptic_delays</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;probability&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">probability</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_attach_drive</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">drive</span><span class="p">,</span>
            <span class="n">weights_ampa</span><span class="p">,</span>
            <span class="n">weights_nmda</span><span class="p">,</span>
            <span class="n">location</span><span class="p">,</span>
            <span class="n">space_constant</span><span class="p">,</span>
            <span class="n">synaptic_delays</span><span class="p">,</span>
            <span class="n">n_drive_cells</span><span class="p">,</span>
            <span class="n">cell_specific</span><span class="p">,</span>
            <span class="n">probability</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Network.add_spike_train_drive">
<a class="viewcode-back" href="../../generated/hnn_core.Network.html#hnn_core.Network.add_spike_train_drive">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_spike_train_drive</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">spike_data</span><span class="p">,</span>
        <span class="n">location</span><span class="p">,</span>
        <span class="n">weights_ampa</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">weights_nmda</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">synaptic_delays</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">space_constant</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>
        <span class="n">probability</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">conn_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add an external drive from explicitly defined spike trains.</span>

<span class="sd">        This method enables the target network to receive spike trains from a source</span>
<span class="sd">        network (e.g., another HNN simulation) or external data, driving activity in the</span>
<span class="sd">        target network&#39;s cells.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Unique name for the drive (e.g., &#39;drive_from_NetA&#39;).</span>
<span class="sd">        spike_data : dict or list of tuple</span>
<span class="sd">            Spike train data from the **source network** (or external source) in one of</span>
<span class="sd">            three formats:</span>

<span class="sd">            - *Format 1 (dictionary)*: Keys are unique identifiers (str) for source</span>
<span class="sd">            cells and values are lists of spike times in milliseconds. The keys</span>
<span class="sd">            can be any string that helps identify the source.</span>
<span class="sd">            Example:</span>
<span class="sd">            ```</span>
<span class="sd">            {&quot;NetA_L2_pyramidal_GID0&quot;: [10.2, 25.3], &quot;NetA_L5_pyramidal_GID1&quot;: [15.1, 30.4]}</span>
<span class="sd">            ```</span>

<span class="sd">            - *Format 2 (tuples)*: A list of (time, gid) tuples, where each tuple</span>
<span class="sd">            contains a spike time (float, in ms) and a GID (int). The GIDs can be</span>
<span class="sd">            any integers that uniquely identify different source cells.</span>
<span class="sd">            Example:</span>
<span class="sd">            ```</span>
<span class="sd">            [(10.2, 0), (25.3, 1), (15.1, 0), (30.4, 1)]</span>
<span class="sd">            ```</span>

<span class="sd">            - *Format 3*: String path (or glob pattern) to spike files that can be loaded</span>
<span class="sd">            with :func:`~hnn_core.read_spikes`. Example: &quot;path/to/spk_*.txt&quot;</span>

<span class="sd">            Note: The GIDs in both formats refer to the source cells in the originating</span>
<span class="sd">            network (or external data). These are arbitrary identifiers that will be</span>
<span class="sd">            remapped internally to sequential drive cell IDs (0 to n-1) in the target</span>
<span class="sd">            network. Different GIDs should be used for different source cells.</span>
<span class="sd">        location : str</span>
<span class="sd">            Target location of synapses in the target network. Must be &#39;proximal&#39;, &#39;distal&#39;, or</span>
<span class="sd">            &#39;soma&#39;, or a specific section name (when legacy_mode=False).</span>
<span class="sd">        weights_ampa : dict or None</span>
<span class="sd">            Synaptic weights (in uS) of AMPA receptors for each targeted cell type (dict keys).</span>
<span class="sd">            Cell types omitted are set to zero.</span>
<span class="sd">        weights_nmda : dict or None</span>
<span class="sd">            Synaptic weights (in uS) of NMDA receptors for each targeted cell type (dict keys).</span>
<span class="sd">            Cell types omitted are set to zero.</span>
<span class="sd">        synaptic_delays : dict or float</span>
<span class="sd">            Synaptic delay (in ms) at the column origin, dispersed laterally as</span>
<span class="sd">            a function of the space_constant. If float, applies to all target</span>
<span class="sd">            cell types. Use dict to create delay-&gt;cell mapping.</span>
<span class="sd">        space_constant : float</span>
<span class="sd">            Lateral dispersion constant (in units of inplane_distance) for synaptic weights and</span>
<span class="sd">            delays within the target network. Default: 3.0</span>
<span class="sd">        probability : float or dict</span>
<span class="sd">            Connection probability between source and target cells. Default: 1.0 (all-to-all).</span>
<span class="sd">        conn_seed : int</span>
<span class="sd">            Optional seed for random number generator for connectivity (default: None).</span>
<span class="sd">        cell_specific : bool</span>
<span class="sd">            If True, enables cell-specific connectivity (e.g., for 1-to-1 mapping). Default: False.</span>
<span class="sd">        n_drive_cells : str or int</span>
<span class="sd">            Number of drive cells. Use &#39;n_cells&#39; for 1-to-1 mapping with target cell types,</span>
<span class="sd">            or an integer for a fixed number. Default: None (inferred from spike_data).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_legacy_mode</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Spike train drives can only target sections defined in &quot;</span>
                <span class="s2">&quot;`Cell.sect_loc` when `legacy_mode=False`.&quot;</span><span class="p">,</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Create the drive object</span>
        <span class="n">drive</span> <span class="o">=</span> <span class="n">_NetworkDrive</span><span class="p">()</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;spike_train&quot;</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">location</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;events&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># Will be populated during instantiation</span>

        <span class="c1"># Process spike_data into a standardized format</span>
        <span class="n">standardized_data</span><span class="p">,</span> <span class="n">n_drive_cells</span><span class="p">,</span> <span class="n">source_to_gid_map</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_spike_data</span><span class="p">(</span><span class="n">spike_data</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Set drive properties</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;dynamics&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">standardized_data</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;n_drive_cells&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_drive_cells</span>
        <span class="k">if</span> <span class="n">source_to_gid_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;source_to_gid_map&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">source_to_gid_map</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;conn_seed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">conn_seed</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;event_seed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">0</span>  <span class="c1"># Not used for spike train, but included for consistency</span>
        <span class="p">)</span>

        <span class="c1"># Save connection parameters</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;weights_ampa&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights_ampa</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;weights_nmda&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights_nmda</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;synaptic_delays&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">synaptic_delays</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;probability&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">probability</span>

        <span class="c1"># Attach the drive to network cells</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attach_drive</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">drive</span><span class="p">,</span>
            <span class="n">weights_ampa</span><span class="o">=</span><span class="n">weights_ampa</span><span class="p">,</span>
            <span class="n">weights_nmda</span><span class="o">=</span><span class="n">weights_nmda</span><span class="p">,</span>
            <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
            <span class="n">space_constant</span><span class="o">=</span><span class="n">space_constant</span><span class="p">,</span>
            <span class="n">synaptic_delays</span><span class="o">=</span><span class="n">synaptic_delays</span><span class="p">,</span>
            <span class="n">n_drive_cells</span><span class="o">=</span><span class="n">drive</span><span class="p">[</span><span class="s2">&quot;n_drive_cells&quot;</span><span class="p">],</span>
            <span class="n">cell_specific</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">probability</span><span class="o">=</span><span class="n">probability</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_attach_drive</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="n">drive</span><span class="p">,</span>
        <span class="n">weights_ampa</span><span class="p">,</span>
        <span class="n">weights_nmda</span><span class="p">,</span>
        <span class="n">location</span><span class="p">,</span>
        <span class="n">space_constant</span><span class="p">,</span>
        <span class="n">synaptic_delays</span><span class="p">,</span>
        <span class="n">n_drive_cells</span><span class="p">,</span>
        <span class="n">cell_specific</span><span class="p">,</span>
        <span class="n">probability</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attach a drive to network based on connectivity information</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name of drive (must be unique)</span>
<span class="sd">        drive : instance of _NetworkDrive</span>
<span class="sd">            Collection of parameters defining the dynamics of the drive</span>
<span class="sd">        weights_ampa : dict or None</span>
<span class="sd">            Synaptic weights (in uS) of AMPA receptors on each targeted cell</span>
<span class="sd">            type (dict keys). Cell types omitted from the dict are set to zero.</span>
<span class="sd">        weights_nmda : dict or None</span>
<span class="sd">            Synaptic weights (in uS) of NMDA receptors on each targeted cell</span>
<span class="sd">            type (dict keys). Cell types omitted from the dict are set to zero.</span>
<span class="sd">        location : str</span>
<span class="sd">            Target location of synapses. Must be an element of</span>
<span class="sd">            `Cell.sect_loc` such as &#39;proximal&#39; or &#39;distal&#39;, which defines a</span>
<span class="sd">            group of sections, or an existing section such as &#39;soma&#39; or</span>
<span class="sd">            &#39;apical_tuft&#39; (defined in `Cell.sections` for all targeted cells).</span>
<span class="sd">            The parameter `legacy_mode` of the `Network` must be set to `False`</span>
<span class="sd">            to target specific sections.</span>
<span class="sd">        space_constant : float</span>
<span class="sd">            Describes lateral dispersion (from the column origin) of synaptic</span>
<span class="sd">            weights and delays within the simulated column. The constant is</span>
<span class="sd">            measured in the units of ``inplane_distance`` of</span>
<span class="sd">            :class:`~hnn_core.Network`. For example, for ``space_constant=3``,</span>
<span class="sd">            the weights and delays are modulated by the factor</span>
<span class="sd">            ``exp(-(x / (3 * inplane_distance)) ** 2)``, where ``x`` is the</span>
<span class="sd">            physical distance (in um) between the connected cells in the xy</span>
<span class="sd">            plane.</span>
<span class="sd">        synaptic_delays : dict or float</span>
<span class="sd">            Synaptic delay (in ms) at the column origin, dispersed laterally as</span>
<span class="sd">            a function of the space_constant</span>
<span class="sd">        n_drive_cells : int | &#39;n_cells&#39;</span>
<span class="sd">            The number of drive cells (i.e., ArtificialCell objects) that</span>
<span class="sd">            contribute to this drive. If n_drive_cells=&#39;n_cells&#39; and</span>
<span class="sd">            cell_specific=True, an artificial drive cell gets assigned to each</span>
<span class="sd">            available cell in the network with 1-to-1 connectivity (completely</span>
<span class="sd">            unsynchronous). Otherwise, drive cells get assigned with all-to-all</span>
<span class="sd">            connectivity. If you wish to synchronize the timing of this evoked</span>
<span class="sd">            drive across the network in a given trial with one spike, set</span>
<span class="sd">            n_drive_cells=1 and cell_specific=False.</span>
<span class="sd">        cell_specific : bool</span>
<span class="sd">            Whether each artificial drive cell has 1-to-1 (True) or all-to-all</span>
<span class="sd">            (False) connection parameters. Note that 1-to-1</span>
<span class="sd">            connectivity requires that n_drive_cells=&#39;n_cells&#39;, where &#39;n_cells&#39;</span>
<span class="sd">            denotes the number of all available cells that this drive can</span>
<span class="sd">            target in the network.</span>
<span class="sd">        probability : dict or float (default: 1.0)</span>
<span class="sd">            Probability of connection between any src-target pair.</span>
<span class="sd">            Use dict to create probability-&gt;cell mapping. If float, applies to</span>
<span class="sd">            all target cell types</span>

<span class="sd">        Attached drive is stored in self.external_drives[name]</span>
<span class="sd">        self.pos_dict is updated, and self._update_gid_ranges() called</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_drives</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Drive </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> already defined&quot;</span><span class="p">)</span>

        <span class="n">_validate_type</span><span class="p">(</span><span class="n">probability</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="s2">&quot;float or dict&quot;</span><span class="p">)</span>
        <span class="c1"># allow passing weights as None, convert to dict here</span>
        <span class="p">(</span><span class="n">target_populations</span><span class="p">,</span> <span class="n">weights_by_type</span><span class="p">,</span> <span class="n">delays_by_type</span><span class="p">,</span> <span class="n">probability_by_type</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">_get_target_properties</span><span class="p">(</span>
                <span class="n">weights_ampa</span><span class="p">,</span>
                <span class="n">weights_nmda</span><span class="p">,</span>
                <span class="n">synaptic_delays</span><span class="p">,</span>
                <span class="n">location</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="p">,</span>
                <span class="n">probability</span><span class="o">=</span><span class="n">probability</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># weights passed must correspond to cells in the network</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">target_populations</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Allowed drive target cell types are: &quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># enforce the same order as in self.cell_types - necessary for</span>
        <span class="c1"># consistent source gid assignment</span>
        <span class="n">target_populations</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">cell_type</span>
            <span class="k">for</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="n">target_populations</span>
        <span class="p">]</span>

        <span class="c1"># Ensure location exists for all target cells</span>
        <span class="n">cell_sections</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="p">[</span><span class="n">cell_type</span><span class="p">][</span><span class="s2">&quot;cell_object&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sections</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="n">target_populations</span>
        <span class="p">]</span>
        <span class="n">sect_locs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="p">[</span><span class="n">cell_type</span><span class="p">][</span><span class="s2">&quot;cell_object&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sect_loc</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="n">target_populations</span>
        <span class="p">]</span>

        <span class="n">valid_cell_sections</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">cell_sections</span><span class="p">)</span>
        <span class="n">valid_sect_locs</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">sect_locs</span><span class="p">)</span>
        <span class="n">valid_loc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">valid_cell_sections</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">valid_sect_locs</span><span class="p">)</span>

        <span class="n">_check_option</span><span class="p">(</span>
            <span class="s2">&quot;location&quot;</span><span class="p">,</span>
            <span class="n">location</span><span class="p">,</span>
            <span class="n">valid_loc</span><span class="p">,</span>
            <span class="n">extra</span><span class="o">=</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot; (the location &#39;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">&#39; is not defined &quot;</span>
                <span class="s2">&quot;for one of the targeted cells)&quot;</span>
            <span class="p">),</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_legacy_mode</span><span class="p">:</span>
            <span class="c1"># allows tests must match HNN GUI output by preserving original</span>
            <span class="c1"># gid assignment convention</span>
            <span class="n">target_populations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">target_type</span> <span class="ow">in</span> <span class="n">target_populations</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">target_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">weights_by_type</span><span class="p">:</span>
                    <span class="n">weights_by_type</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">target_type</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;ampa&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">}})</span>
                <span class="k">if</span> <span class="n">target_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">delays_by_type</span><span class="p">:</span>
                    <span class="n">delays_by_type</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">target_type</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">})</span>
                <span class="k">if</span> <span class="n">target_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">probability_by_type</span><span class="p">:</span>
                    <span class="n">probability_by_type</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">target_type</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_populations</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No target populations have been specified for this drive.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">cell_specific</span> <span class="ow">and</span> <span class="n">n_drive_cells</span> <span class="o">!=</span> <span class="s2">&quot;n_cells&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;If cell_specific is True, n_drive_cells must&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; equal &#39;n_cells&#39;. Got </span><span class="si">{</span><span class="n">n_drive_cells</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">cell_specific</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_drive_cells</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;If cell_specific is False, n_drive_cells &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;must be of type int. Got &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">n_drive_cells</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">n_drive_cells</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Number of drive cells must be greater than &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;0. Got </span><span class="si">{</span><span class="n">n_drive_cells</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>  <span class="c1"># for easier for-looping later</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;target_types&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_populations</span>  <span class="c1"># for _connect_celltypes</span>
        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;cell_specific&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_specific</span>

        <span class="k">if</span> <span class="n">n_drive_cells</span> <span class="o">==</span> <span class="s2">&quot;n_cells&quot;</span><span class="p">:</span>
            <span class="n">n_drive_cells</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="n">target_populations</span><span class="p">:</span>
                <span class="n">n_drive_cells</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gid_ranges</span><span class="p">[</span><span class="n">cell_type</span><span class="p">])</span>

        <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;n_drive_cells&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_drive_cells</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">external_drives</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">drive</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_dict</span><span class="p">[</span><span class="s2">&quot;origin&quot;</span><span class="p">]]</span> <span class="o">*</span> <span class="n">n_drive_cells</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_cell_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>

        <span class="c1"># Set the starting index for cell-specific source gids</span>
        <span class="c1"># This will be updated depending on the number of target cells</span>
        <span class="c1"># of each cell type</span>
        <span class="n">src_idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># seed_increment increased by 1 for each target cell type,</span>
        <span class="c1"># added to conn_seed to ensure statistical independence of random</span>
        <span class="c1"># connections when probability &lt; 1.0</span>
        <span class="k">for</span> <span class="n">seed_increment</span><span class="p">,</span> <span class="n">target_cell_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_populations</span><span class="p">):</span>
            <span class="n">target_gids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gid_ranges</span><span class="p">[</span><span class="n">target_cell_type</span><span class="p">])</span>
            <span class="n">delays</span> <span class="o">=</span> <span class="n">delays_by_type</span><span class="p">[</span><span class="n">target_cell_type</span><span class="p">]</span>
            <span class="n">probability</span> <span class="o">=</span> <span class="n">probability_by_type</span><span class="p">[</span><span class="n">target_cell_type</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cell_specific</span><span class="p">:</span>
                <span class="n">target_gids_nested</span> <span class="o">=</span> <span class="p">[[</span><span class="n">target_gid</span><span class="p">]</span> <span class="k">for</span> <span class="n">target_gid</span> <span class="ow">in</span> <span class="n">target_gids</span><span class="p">]</span>
                <span class="n">src_idx_end</span> <span class="o">=</span> <span class="n">src_idx</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_gids</span><span class="p">)</span>
                <span class="n">src_gids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gid_ranges</span><span class="p">[</span><span class="n">name</span><span class="p">])[</span><span class="n">src_idx</span><span class="p">:</span><span class="n">src_idx_end</span><span class="p">]</span>
                <span class="n">src_idx</span> <span class="o">=</span> <span class="n">src_idx_end</span>
                <span class="k">for</span> <span class="n">receptor_idx</span><span class="p">,</span> <span class="n">receptor</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                    <span class="n">weights_by_type</span><span class="p">[</span><span class="n">target_cell_type</span><span class="p">]</span>
                <span class="p">):</span>
                    <span class="n">weights</span> <span class="o">=</span> <span class="n">weights_by_type</span><span class="p">[</span><span class="n">target_cell_type</span><span class="p">][</span><span class="n">receptor</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_connection</span><span class="p">(</span>
                        <span class="n">src_gids</span><span class="o">=</span><span class="n">src_gids</span><span class="p">,</span>
                        <span class="n">target_gids</span><span class="o">=</span><span class="n">target_gids_nested</span><span class="p">,</span>
                        <span class="n">loc</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
                        <span class="n">receptor</span><span class="o">=</span><span class="n">receptor</span><span class="p">,</span>
                        <span class="n">weight</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                        <span class="n">delay</span><span class="o">=</span><span class="n">delays</span><span class="p">,</span>
                        <span class="n">lamtha</span><span class="o">=</span><span class="n">space_constant</span><span class="p">,</span>
                        <span class="n">probability</span><span class="o">=</span><span class="n">probability</span><span class="p">,</span>
                        <span class="n">conn_seed</span><span class="o">=</span><span class="n">drive</span><span class="p">[</span><span class="s2">&quot;conn_seed&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">seed_increment</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="c1"># Ensure that AMPA/NMDA connections target the same gids</span>
                    <span class="k">if</span> <span class="n">receptor_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;src_gids&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span>
                            <span class="s2">&quot;src_gids&quot;</span>
                        <span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">receptor_idx</span><span class="p">,</span> <span class="n">receptor</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                    <span class="n">weights_by_type</span><span class="p">[</span><span class="n">target_cell_type</span><span class="p">]</span>
                <span class="p">):</span>
                    <span class="n">weights</span> <span class="o">=</span> <span class="n">weights_by_type</span><span class="p">[</span><span class="n">target_cell_type</span><span class="p">][</span><span class="n">receptor</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_connection</span><span class="p">(</span>
                        <span class="n">src_gids</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                        <span class="n">target_gids</span><span class="o">=</span><span class="n">target_gids</span><span class="p">,</span>
                        <span class="n">loc</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
                        <span class="n">receptor</span><span class="o">=</span><span class="n">receptor</span><span class="p">,</span>
                        <span class="n">weight</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                        <span class="n">delay</span><span class="o">=</span><span class="n">delays</span><span class="p">,</span>
                        <span class="n">lamtha</span><span class="o">=</span><span class="n">space_constant</span><span class="p">,</span>
                        <span class="n">probability</span><span class="o">=</span><span class="n">probability</span><span class="p">,</span>
                        <span class="n">conn_seed</span><span class="o">=</span><span class="n">drive</span><span class="p">[</span><span class="s2">&quot;conn_seed&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">seed_increment</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="c1"># Ensure that AMPA/NMDA connections target the same gids</span>
                    <span class="c1"># when probability &lt; 1</span>
                    <span class="k">if</span> <span class="n">receptor_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;src_gids&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span>
                            <span class="s2">&quot;src_gids&quot;</span>
                        <span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_reset_drives</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># reset every time called again, e.g., from dipole.py or in self.copy()</span>
        <span class="k">for</span> <span class="n">drive_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_drives</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">external_drives</span><span class="p">[</span><span class="n">drive_name</span><span class="p">][</span><span class="s2">&quot;events&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_reset_rec_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># clear the data in rec_arrays</span>
        <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rec_arrays</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">_reset</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_instantiate_drives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">n_trials</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates event time vectors for all drives across trials</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tstop : float</span>
<span class="sd">            The simulation stop time (ms)</span>
<span class="sd">        n_trials : int</span>
<span class="sd">            Number of trials to create events for (default: 1)</span>

<span class="sd">        NB this must be a separate method because dipole.py:simulate_dipole</span>
<span class="sd">        accepts an n_trials-argument, which overrides the N_trials-parameter</span>
<span class="sd">        used at initialisation time. The good news is that only the event_times</span>
<span class="sd">        need to be recalculated, all the GIDs etc remain the same.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_drives</span><span class="p">()</span>

        <span class="c1"># each trial needs unique event time vectors</span>
        <span class="k">for</span> <span class="n">trial_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_trials</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">drive</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_drives</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">event_times</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># new list for each trial and drive</span>
                <span class="k">for</span> <span class="n">drive_cell_gid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gid_ranges</span><span class="p">[</span><span class="n">drive</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]]:</span>
                    <span class="n">drive_cell_gid_offset</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">drive_cell_gid</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">gid_ranges</span><span class="p">[</span><span class="n">drive</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">trial_seed_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_gids</span>
                    <span class="k">if</span> <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;cell_specific&quot;</span><span class="p">]:</span>
                        <span class="c1"># loop over drives (one for each target cell</span>
                        <span class="c1"># population) and create event times</span>
                        <span class="n">conn_idxs</span> <span class="o">=</span> <span class="n">pick_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_gids</span><span class="o">=</span><span class="n">drive_cell_gid</span><span class="p">)</span>
                        <span class="n">target_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">conn_idx</span><span class="p">][</span><span class="s2">&quot;target_type&quot;</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">conn_idx</span> <span class="ow">in</span> <span class="n">conn_idxs</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">target_type</span> <span class="ow">in</span> <span class="n">target_types</span><span class="p">:</span>
                            <span class="n">event_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="n">_drive_cell_event_times</span><span class="p">(</span>
                                    <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span>
                                    <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;dynamics&quot;</span><span class="p">],</span>
                                    <span class="n">target_type</span><span class="o">=</span><span class="n">target_type</span><span class="p">,</span>
                                    <span class="n">trial_idx</span><span class="o">=</span><span class="n">trial_idx</span><span class="p">,</span>
                                    <span class="n">drive_cell_gid</span><span class="o">=</span><span class="n">drive_cell_gid_offset</span><span class="p">,</span>
                                    <span class="n">event_seed</span><span class="o">=</span><span class="n">drive</span><span class="p">[</span><span class="s2">&quot;event_seed&quot;</span><span class="p">],</span>
                                    <span class="n">tstop</span><span class="o">=</span><span class="n">tstop</span><span class="p">,</span>
                                    <span class="n">trial_seed_offset</span><span class="o">=</span><span class="n">trial_seed_offset</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">src_event_times</span> <span class="o">=</span> <span class="n">_drive_cell_event_times</span><span class="p">(</span>
                            <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span>
                            <span class="n">drive</span><span class="p">[</span><span class="s2">&quot;dynamics&quot;</span><span class="p">],</span>
                            <span class="n">tstop</span><span class="o">=</span><span class="n">tstop</span><span class="p">,</span>
                            <span class="n">target_type</span><span class="o">=</span><span class="s2">&quot;any&quot;</span><span class="p">,</span>
                            <span class="n">trial_idx</span><span class="o">=</span><span class="n">trial_idx</span><span class="p">,</span>
                            <span class="n">drive_cell_gid</span><span class="o">=</span><span class="n">drive_cell_gid_offset</span><span class="p">,</span>
                            <span class="n">event_seed</span><span class="o">=</span><span class="n">drive</span><span class="p">[</span><span class="s2">&quot;event_seed&quot;</span><span class="p">],</span>
                            <span class="n">trial_seed_offset</span><span class="o">=</span><span class="n">trial_seed_offset</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">event_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src_event_times</span><span class="p">)</span>
                <span class="c1"># &#39;events&#39;: nested list (n_trials x n_drive_cells x n_events)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">external_drives</span><span class="p">[</span><span class="n">drive</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]][</span><span class="s2">&quot;events&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event_times</span><span class="p">)</span>

<div class="viewcode-block" id="Network.add_tonic_bias">
<a class="viewcode-back" href="../../generated/hnn_core.Network.html#hnn_core.Network.add_tonic_bias">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_tonic_bias</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">cell_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">section</span><span class="o">=</span><span class="s2">&quot;soma&quot;</span><span class="p">,</span>
        <span class="n">bias_name</span><span class="o">=</span><span class="s2">&quot;tonic&quot;</span><span class="p">,</span>
        <span class="n">amplitude</span><span class="p">,</span>
        <span class="n">t0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">tstop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attaches parameters of tonic bias input for given cell types</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cell_types : str | None</span>
<span class="sd">            The name of the cell type to add a tonic input. When supplied,</span>
<span class="sd">            a float value must be provided with the `amplitude` keyword.</span>
<span class="sd">            Valid inputs are those listed in  `net.cell_types`.</span>
<span class="sd">        section : str</span>
<span class="sd">            name of cell section the bias should be applied to.</span>
<span class="sd">            See net.cell_types[cell_type].sections.keys()</span>
<span class="sd">        bias_name : str</span>
<span class="sd">            The name of the bias.</span>
<span class="sd">        amplitude: dict | float</span>
<span class="sd">            A dictionary of cell type keys (str) to amplitude values (float).</span>
<span class="sd">            Valid inputs for cell types are those listed in `net.cell_types`.</span>
<span class="sd">            If `cell_types` is not None, `amplitude` should be</span>
<span class="sd">            a float indicating the amplitude of the tonic input</span>
<span class="sd">            for the specified cell type.</span>
<span class="sd">        t0 : float</span>
<span class="sd">            The start time of tonic input (in ms). Default: 0 (beginning of</span>
<span class="sd">            simulation). This value will be applied to all the  tonic biases if</span>
<span class="sd">            multiple are specified with the `amplitude` keyword.</span>
<span class="sd">        tstop : float</span>
<span class="sd">            The end time of tonic input (in ms). Default: end of simulation.</span>
<span class="sd">            This value will be applied to all the  tonic biases if</span>
<span class="sd">            multiple are specified with the `amplitude` keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># old functionality single cell type - amplitude</span>
        <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;cell_type argument will be deprecated and &quot;</span>
                <span class="s2">&quot;removed in future releases. Use amplitude as a &quot;</span>
                <span class="s2">&quot;cell_type:str,amplitude:float dictionary.&quot;</span>
                <span class="s2">&quot;Read the function docustring for more information&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">_validate_type</span><span class="p">(</span><span class="n">amplitude</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;amplitude&quot;</span><span class="p">)</span>

            <span class="n">_add_cell_type_bias</span><span class="p">(</span>
                <span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">cell_type</span><span class="o">=</span><span class="n">cell_type</span><span class="p">,</span>
                <span class="n">section</span><span class="o">=</span><span class="n">section</span><span class="p">,</span>
                <span class="n">bias_name</span><span class="o">=</span><span class="n">bias_name</span><span class="p">,</span>
                <span class="n">amplitude</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">amplitude</span><span class="p">),</span>
                <span class="n">t_0</span><span class="o">=</span><span class="n">t0</span><span class="p">,</span>
                <span class="n">t_stop</span><span class="o">=</span><span class="n">tstop</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_validate_type</span><span class="p">(</span><span class="n">amplitude</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="s2">&quot;amplitude&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">amplitude</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;No bias have been defined, no action taken&quot;</span><span class="p">,</span>
                    <span class="ne">UserWarning</span><span class="p">,</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">return</span>

            <span class="k">for</span> <span class="n">_cell_type</span><span class="p">,</span> <span class="n">_amplitude</span> <span class="ow">in</span> <span class="n">amplitude</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">_add_cell_type_bias</span><span class="p">(</span>
                    <span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">cell_type</span><span class="o">=</span><span class="n">_cell_type</span><span class="p">,</span>
                    <span class="n">section</span><span class="o">=</span><span class="n">section</span><span class="p">,</span>
                    <span class="n">bias_name</span><span class="o">=</span><span class="n">bias_name</span><span class="p">,</span>
                    <span class="n">amplitude</span><span class="o">=</span><span class="n">_amplitude</span><span class="p">,</span>
                    <span class="n">t_0</span><span class="o">=</span><span class="n">t0</span><span class="p">,</span>
                    <span class="n">t_stop</span><span class="o">=</span><span class="n">tstop</span><span class="p">,</span>
                <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_add_cell_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_name</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">cell_template</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add cell type by updating pos_dict and gid_ranges.&quot;&quot;&quot;</span>
        <span class="n">ll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_gids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_gids</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gid_ranges</span><span class="p">[</span><span class="n">cell_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">ll</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_gids</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos_dict</span><span class="p">[</span><span class="n">cell_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="k">if</span> <span class="n">cell_template</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">cell_name</span><span class="p">:</span> <span class="n">cell_template</span><span class="p">})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_cells</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_rename_cell_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_mapping</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Renames cell types in the network.</span>

<span class="sd">        XXX: All HNN functionality is not supported, such as Dipole calculation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name_mapping: dict[str, str]</span>
<span class="sd">            Dictionary of what cell type names to change, and what to change</span>
<span class="sd">            them to. Keys are existing cell type name strings, and values are</span>
<span class="sd">            what string to change each key to. Note that both elements must be</span>
<span class="sd">            strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_validate_type</span><span class="p">(</span><span class="n">name_mapping</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="s2">&quot;name_mapping&quot;</span><span class="p">)</span>

        <span class="c1"># Store original cell object names to preserve them</span>
        <span class="n">original_cell_names</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">original_name</span> <span class="ow">in</span> <span class="n">name_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">original_name</span><span class="p">),</span> <span class="nb">dict</span><span class="p">)</span>
                <span class="ow">and</span> <span class="s2">&quot;cell_object&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="p">[</span><span class="n">original_name</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">original_cell_names</span><span class="p">[</span><span class="n">original_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="p">[</span><span class="n">original_name</span><span class="p">][</span>
                    <span class="s2">&quot;cell_object&quot;</span>
                <span class="p">]</span><span class="o">.</span><span class="n">name</span>

        <span class="k">for</span> <span class="n">original_name</span><span class="p">,</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="n">name_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">original_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">original_name</span><span class="si">}</span><span class="s2">&#39; is not in cell_types!&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">new_name</span><span class="si">}</span><span class="s2">&#39; is already in cell_types!&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">original_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">attr_name</span> <span class="ow">in</span> <span class="p">[</span>
                    <span class="s2">&quot;cell_types&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;pos_dict&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;external_biases&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;external_drives&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;gid_ranges&quot;</span><span class="p">,</span>
                <span class="p">]:</span>
                    <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                        <span class="n">updated_attr</span> <span class="o">=</span> <span class="n">_replace_dict_identifier</span><span class="p">(</span>
                            <span class="n">attr</span><span class="p">,</span> <span class="n">original_name</span><span class="p">,</span> <span class="n">new_name</span>
                        <span class="p">)</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">updated_attr</span><span class="p">)</span>

                <span class="c1"># Update Network.connectivity</span>
                <span class="k">for</span> <span class="n">connection</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">connection</span><span class="p">[</span><span class="s2">&quot;src_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">original_name</span><span class="p">:</span>
                        <span class="n">connection</span><span class="p">[</span><span class="s2">&quot;src_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_name</span>
                    <span class="k">if</span> <span class="n">connection</span><span class="p">[</span><span class="s2">&quot;target_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">original_name</span><span class="p">:</span>
                        <span class="n">connection</span><span class="p">[</span><span class="s2">&quot;target_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_name</span>

                <span class="c1"># Restore original cell object name to preserve cell template identity</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">new_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span>
                    <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="p">[</span><span class="n">new_name</span><span class="p">],</span> <span class="nb">dict</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="s2">&quot;cell_object&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span>
                    <span class="ow">and</span> <span class="n">original_name</span> <span class="ow">in</span> <span class="n">original_cell_names</span>
                <span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="p">[</span><span class="n">new_name</span><span class="p">][</span><span class="s2">&quot;cell_object&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">original_cell_names</span><span class="p">[</span>
                        <span class="n">original_name</span>
                    <span class="p">]</span>

<div class="viewcode-block" id="Network.gid_to_type">
<a class="viewcode-back" href="../../generated/hnn_core.Network.html#hnn_core.Network.gid_to_type">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">gid_to_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reverse lookup of gid to type.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_gid_to_type</span><span class="p">(</span><span class="n">gid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gid_ranges</span><span class="p">)</span></div>


<div class="viewcode-block" id="Network.add_connection">
<a class="viewcode-back" href="../../generated/hnn_core.Network.html#hnn_core.Network.add_connection">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_connection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">src_gids</span><span class="p">,</span>
        <span class="n">target_gids</span><span class="p">,</span>
        <span class="n">loc</span><span class="p">,</span>
        <span class="n">receptor</span><span class="p">,</span>
        <span class="n">weight</span><span class="p">,</span>
        <span class="n">delay</span><span class="p">,</span>
        <span class="n">lamtha</span><span class="p">,</span>
        <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">gain</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">allow_autapses</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">probability</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">conn_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Appends connections to connectivity list</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_gids : str | int | range | list of int</span>
<span class="sd">            Identifier for source cells. Passing str arguments (&#39;evdist1&#39;,</span>
<span class="sd">            &#39;L2_pyramidal&#39;, &#39;L2_basket&#39;, &#39;L5_pyramidal&#39;, &#39;L5_basket&#39;, etc.) is</span>
<span class="sd">            equivalent to passing a list of gids for the relevant cell type.</span>
<span class="sd">            source - target connections are made in an all-to-all pattern.</span>
<span class="sd">        target_gids : str | int | range | list of int</span>
<span class="sd">            Identifier for targets of source cells. Passing str arguments</span>
<span class="sd">            (&#39;L2_pyramidal&#39;, &#39;L2_basket&#39;, &#39;L5_pyramidal&#39;, &#39;L5_basket&#39;) is</span>
<span class="sd">            equivalent to passing a list of gids for the relevant cell type.</span>
<span class="sd">            source - target connections are made in an all-to-all pattern.</span>
<span class="sd">        loc : str</span>
<span class="sd">            Target location of synapses. Must be an element of</span>
<span class="sd">            `Cell.sect_loc` such as &#39;proximal&#39; or &#39;distal&#39;, which defines a</span>
<span class="sd">            group of sections, or an existing section such as &#39;soma&#39; or</span>
<span class="sd">            &#39;apical_tuft&#39; (defined in `Cell.sections` for all targeted cells).</span>
<span class="sd">            The parameter `legacy_mode` of the `Network` must be set to `False`</span>
<span class="sd">            to target specific sections.</span>
<span class="sd">        receptor : str</span>
<span class="sd">            Synaptic receptor of connection. Must be one of:</span>
<span class="sd">            &#39;ampa&#39;, &#39;nmda&#39;, &#39;gabaa&#39;, or &#39;gabab&#39;.</span>
<span class="sd">        weight : float</span>
<span class="sd">            Synaptic weight on target cell.</span>
<span class="sd">        delay : float</span>
<span class="sd">            Synaptic delay in ms.</span>
<span class="sd">        lamtha : float</span>
<span class="sd">            Space constant.</span>
<span class="sd">        threshold : float, default=None</span>
<span class="sd">            Firing threshold of cells for connection. If None (the default), inherit the</span>
<span class="sd">            threshold from the Network object.</span>
<span class="sd">        gain : float, default=1.0</span>
<span class="sd">            Multiplicative factor for synaptic weight.</span>
<span class="sd">        allow_autapses : bool, default=True</span>
<span class="sd">            If True, allow connecting neuron to itself.</span>
<span class="sd">        probability : float, default=1.0</span>
<span class="sd">            Probability of connection between any src-target pair.</span>
<span class="sd">            Defaults to 1.0 producing an all-to-all pattern.</span>
<span class="sd">        conn_seed : int, default=None</span>
<span class="sd">            Optional initial seed for random number generator (default: None).</span>
<span class="sd">            Used to randomly remove connections when probability &lt; 1.0.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Connections are stored in ``net.connectivity[idx][&#39;gid_pairs&#39;]``, a</span>
<span class="sd">        dictionary indexed by src gids with the format:</span>
<span class="sd">        {src_gid: [target_gids, ...], ...} where each src_gid indexes a list of</span>
<span class="sd">        all its targets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">_Connectivity</span><span class="p">()</span>
        <span class="c1"># Threshold&#39;s value is validated later below with the rest of nc_dict</span>
        <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span>
        <span class="n">_validate_type</span><span class="p">(</span>
            <span class="n">target_gids</span><span class="p">,</span>
            <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span>
            <span class="s2">&quot;target_gids&quot;</span><span class="p">,</span>
            <span class="s2">&quot;int list, range or str&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">_validate_type</span><span class="p">(</span><span class="n">allow_autapses</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="s2">&quot;target_gids&quot;</span><span class="p">,</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span>
        <span class="n">valid_source_cells</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gid_ranges</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># Convert src_gids to list</span>
        <span class="n">src_gids</span> <span class="o">=</span> <span class="n">_check_gids</span><span class="p">(</span>
            <span class="n">src_gids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gid_ranges</span><span class="p">,</span> <span class="n">valid_source_cells</span><span class="p">,</span> <span class="s2">&quot;src_gids&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Convert target_gids to list of list, one element for each src_gid</span>
        <span class="n">valid_target_cells</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_gids</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">target_gids</span> <span class="o">=</span> <span class="p">[[</span><span class="n">target_gids</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">src_gids</span><span class="p">))]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_gids</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">_check_option</span><span class="p">(</span><span class="s2">&quot;target_gids&quot;</span><span class="p">,</span> <span class="n">target_gids</span><span class="p">,</span> <span class="n">valid_target_cells</span><span class="p">)</span>
            <span class="n">target_gids</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gid_ranges</span><span class="p">[</span><span class="n">_long_name</span><span class="p">(</span><span class="n">target_gids</span><span class="p">)])</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">src_gids</span><span class="p">))</span>
            <span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_gids</span><span class="p">,</span> <span class="nb">range</span><span class="p">):</span>
            <span class="n">target_gids</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">target_gids</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">src_gids</span><span class="p">))]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_gids</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_gid</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">t_gid</span> <span class="ow">in</span> <span class="n">target_gids</span>
        <span class="p">):</span>
            <span class="n">target_gids</span> <span class="o">=</span> <span class="p">[</span><span class="n">target_gids</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">src_gids</span><span class="p">))]</span>

        <span class="c1"># Validate each target list - src pairs.</span>
        <span class="c1"># set() used to avoid redundant checks.</span>
        <span class="n">target_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">target_src_pair</span> <span class="ow">in</span> <span class="n">target_gids</span><span class="p">:</span>
            <span class="n">_validate_type</span><span class="p">(</span><span class="n">target_src_pair</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="s2">&quot;target_gids[idx]&quot;</span><span class="p">,</span> <span class="s2">&quot;list or range&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">target_gid</span> <span class="ow">in</span> <span class="n">target_src_pair</span><span class="p">:</span>
                <span class="n">target_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target_gid</span><span class="p">)</span>
        <span class="n">target_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gid_to_type</span><span class="p">(</span><span class="n">target_gids</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">target_gid</span> <span class="ow">in</span> <span class="n">target_set</span><span class="p">:</span>
            <span class="n">_validate_type</span><span class="p">(</span><span class="n">target_gid</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;target_gid&quot;</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span>
            <span class="c1"># Ensure gids in range of Network.gid_ranges</span>
            <span class="n">gid_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gid_to_type</span><span class="p">(</span><span class="n">target_gid</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gid_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;target_gid </span><span class="si">{</span><span class="n">target_gid</span><span class="si">}</span><span class="s2">not in net.gid_ranges&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">gid_type</span> <span class="o">!=</span> <span class="n">target_type</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;All target_gids must be of the same type&quot;</span><span class="p">)</span>
        <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;target_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_type</span>
        <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;target_gids&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_set</span>
        <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;num_targets&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_set</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_gids</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">src_gids</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;target_gids must have a list for each src.&quot;</span><span class="p">)</span>

        <span class="c1"># Format gid_pairs and add to conn dictionary</span>
        <span class="n">gid_pairs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">src_gid</span><span class="p">,</span> <span class="n">target_src_pair</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">src_gids</span><span class="p">,</span> <span class="n">target_gids</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_autapses</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">target_src_pair</span><span class="p">,</span> <span class="n">src_gid</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">target_src_pair</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">target_src_pair</span><span class="p">)[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">gid_pairs</span><span class="p">[</span><span class="n">src_gid</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_src_pair</span>

        <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;src_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gid_to_type</span><span class="p">(</span><span class="n">src_gids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;src_gids&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">src_gids</span><span class="p">)</span>
        <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;num_srcs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">src_gids</span><span class="p">)</span>

        <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;gid_pairs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gid_pairs</span>

        <span class="c1"># Validate string inputs</span>
        <span class="n">_validate_type</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">)</span>
        <span class="n">_validate_type</span><span class="p">(</span><span class="n">receptor</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;receptor&quot;</span><span class="p">)</span>

        <span class="n">target_sect_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="p">[</span><span class="n">target_type</span><span class="p">][</span><span class="s2">&quot;cell_object&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sect_loc</span>
        <span class="n">target_sections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="p">[</span><span class="n">target_type</span><span class="p">][</span><span class="s2">&quot;cell_object&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sections</span>
        <span class="n">valid_loc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">target_sect_loc</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">target_sections</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">_check_option</span><span class="p">(</span>
            <span class="s2">&quot;loc&quot;</span><span class="p">,</span>
            <span class="n">loc</span><span class="p">,</span>
            <span class="n">valid_loc</span><span class="p">,</span>
            <span class="n">extra</span><span class="o">=</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; (the loc &#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39; is not defined for &#39;</span><span class="si">{</span><span class="n">target_type</span><span class="si">}</span><span class="s2">&#39; cells)&quot;</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>

        <span class="c1"># `loc` specifies a group of sections, all must contain the synapse</span>
        <span class="c1"># specified by `receptor`</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">target_sect_loc</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sec_name</span> <span class="ow">in</span> <span class="n">target_sect_loc</span><span class="p">[</span><span class="n">loc</span><span class="p">]:</span>
                <span class="n">valid_receptor</span> <span class="o">=</span> <span class="n">target_sections</span><span class="p">[</span><span class="n">sec_name</span><span class="p">]</span><span class="o">.</span><span class="n">syns</span>
                <span class="n">_check_option</span><span class="p">(</span>
                    <span class="s2">&quot;receptor&quot;</span><span class="p">,</span>
                    <span class="n">receptor</span><span class="p">,</span>
                    <span class="n">valid_receptor</span><span class="p">,</span>
                    <span class="n">extra</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot; (the &#39;</span><span class="si">{</span><span class="n">receptor</span><span class="si">}</span><span class="s2">&#39; receptor is not &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;defined for the &#39;</span><span class="si">{</span><span class="n">sec_name</span><span class="si">}</span><span class="s2">&#39; of&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">target_type</span><span class="si">}</span><span class="s2">&#39; cells)&quot;</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="c1"># `loc` specifies an individual section</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">valid_receptor</span> <span class="o">=</span> <span class="n">target_sections</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="o">.</span><span class="n">syns</span>
            <span class="n">_check_option</span><span class="p">(</span>
                <span class="s2">&quot;receptor&quot;</span><span class="p">,</span>
                <span class="n">receptor</span><span class="p">,</span>
                <span class="n">valid_receptor</span><span class="p">,</span>
                <span class="n">extra</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;(the &#39;</span><span class="si">{</span><span class="n">receptor</span><span class="si">}</span><span class="s2">&#39; receptor is not &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;defined for the &#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39; of&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">target_type</span><span class="si">}</span><span class="s2">&#39; cells)&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;receptor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">receptor</span>

        <span class="c1"># Create and validate nc_dict</span>
        <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;nc_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">arg_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;delay&quot;</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="s2">&quot;lamtha&quot;</span><span class="p">,</span> <span class="s2">&quot;threshold&quot;</span><span class="p">,</span> <span class="s2">&quot;gain&quot;</span><span class="p">]</span>
        <span class="n">nc_dict_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;A_delay&quot;</span><span class="p">,</span> <span class="s2">&quot;A_weight&quot;</span><span class="p">,</span> <span class="s2">&quot;lamtha&quot;</span><span class="p">,</span> <span class="s2">&quot;threshold&quot;</span><span class="p">,</span> <span class="s2">&quot;gain&quot;</span><span class="p">]</span>
        <span class="n">nc_conn_items</span> <span class="o">=</span> <span class="p">[</span><span class="n">delay</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">lamtha</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">gain</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nc_dict_keys</span><span class="p">,</span> <span class="n">arg_names</span><span class="p">,</span> <span class="n">nc_conn_items</span><span class="p">):</span>
            <span class="n">_validate_type</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="n">arg_name</span><span class="p">,</span> <span class="s2">&quot;int or float&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">arg_name</span> <span class="o">==</span> <span class="s2">&quot;gain&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">item</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Synaptic gains must be non-negative.&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="n">gain</span><span class="si">}</span><span class="s2"> for connection </span><span class="si">{</span><span class="n">conn</span><span class="p">[</span><span class="s1">&#39;src_type&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">conn</span><span class="p">[</span><span class="s1">&#39;target_type&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>

            <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;nc_dict&quot;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span>

        <span class="c1"># Probabilistically define connections</span>
        <span class="k">if</span> <span class="n">probability</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">_connection_probability</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">probability</span><span class="p">,</span> <span class="n">conn_seed</span><span class="p">)</span>

        <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;probability&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">probability</span>
        <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;allow_autapses&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">allow_autapses</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">conn</span><span class="p">))</span></div>


<div class="viewcode-block" id="Network.clear_connectivity">
<a class="viewcode-back" href="../../generated/hnn_core.Network.html#hnn_core.Network.clear_connectivity">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clear_connectivity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove all connections defined in Network.connectivity&quot;&quot;&quot;</span>
        <span class="n">connectivity</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">conn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;src_type&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_drives</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">connectivity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span> <span class="o">=</span> <span class="n">connectivity</span></div>


<div class="viewcode-block" id="Network.clear_drives">
<a class="viewcode-back" href="../../generated/hnn_core.Network.html#hnn_core.Network.clear_drives">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clear_drives</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove all drives defined in Network.connectivity&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">conn</span>
            <span class="k">for</span> <span class="n">conn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span>
            <span class="k">if</span> <span class="n">conn</span><span class="p">[</span><span class="s2">&quot;src_type&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_drives</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">cell_name</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gid_ranges</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">cell_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_drives</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_n_gids</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gid_ranges</span><span class="p">[</span><span class="n">cell_name</span><span class="p">])</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">gid_ranges</span><span class="p">[</span><span class="n">cell_name</span><span class="p">]</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_dict</span><span class="p">[</span><span class="n">cell_name</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">external_drives</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span></div>


<div class="viewcode-block" id="Network.add_electrode_array">
<a class="viewcode-back" href="../../generated/hnn_core.Network.html#hnn_core.Network.add_electrode_array">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_electrode_array</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">electrode_pos</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">conductivity</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;psa&quot;</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="mf">0.5</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Specify coordinates of electrode array for extracellular recording.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Unique name of the array.</span>
<span class="sd">        electrode_pos : tuple | list of tuple</span>
<span class="sd">            Coordinates specifying the position for extracellular electrodes in</span>
<span class="sd">            the form of (x, y, z) (in um).</span>
<span class="sd">        conductivity : float</span>
<span class="sd">            Extracellular conductivity, in S/m, of the assumed infinite,</span>
<span class="sd">            homogeneous volume conductor that the cell and electrode are in.</span>
<span class="sd">        method : str</span>
<span class="sd">            Approximation to use. ``&#39;psa&#39;`` (point source approximation) treats</span>
<span class="sd">            each segment junction as a point extracellular current source.</span>
<span class="sd">            ``&#39;lsa&#39;`` (line source approximation) treats each segment as a line</span>
<span class="sd">            source of current, which extends from the previous to the next</span>
<span class="sd">            segment center point: /---x---/, where x is the current segment</span>
<span class="sd">            flanked by /.</span>
<span class="sd">        min_distance : float (default: 0.5; unit: um)</span>
<span class="sd">            To avoid numerical errors in calculating potentials, apply a</span>
<span class="sd">            minimum distance limit between the electrode contacts and the</span>
<span class="sd">            active neuronal membrane elements that act as sources of current.</span>
<span class="sd">            The default value of 0.5 um corresponds to 1 um diameter dendrites.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_validate_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rec_arrays</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> already exists, use another name!&quot;</span><span class="p">)</span>

        <span class="c1"># let ExtracellularArray perform all remaining argument checks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rec_arrays</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="n">name</span><span class="p">:</span> <span class="n">ExtracellularArray</span><span class="p">(</span>
                    <span class="n">electrode_pos</span><span class="p">,</span>
                    <span class="n">conductivity</span><span class="o">=</span><span class="n">conductivity</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                    <span class="n">min_distance</span><span class="o">=</span><span class="n">min_distance</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">}</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Network.set_global_synaptic_gains">
<a class="viewcode-back" href="../../generated/hnn_core.Network.html#hnn_core.Network.set_global_synaptic_gains">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_global_synaptic_gains</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">e_e</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">e_i</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">i_e</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">i_i</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Change the synaptic gains of the celltypes in the Network.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        e_e : float, default=None</span>
<span class="sd">            Synaptic gain of excitatory to excitatory connections</span>
<span class="sd">        e_i : float, default=None</span>
<span class="sd">            Synaptic gain of excitatory to inhibitory connections</span>
<span class="sd">        i_e : float, default=None</span>
<span class="sd">            Synaptic gain of inhibitory to excitatory connections</span>
<span class="sd">        i_i : float, default=None</span>
<span class="sd">            Synaptic gain of inhibitory to inhibitory connections</span>
<span class="sd">        copy : bool, default=False</span>
<span class="sd">            If True, returns a copy of the network. If False,</span>
<span class="sd">            the network is updated in place with a return of None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        net : instance of Network</span>
<span class="sd">            A copy of the instance with updated synaptic gains if copy=True.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Synaptic gains must be non-negative. The synaptic gains will only be</span>
<span class="sd">        updated if a float value is provided. If None is provided</span>
<span class="sd">        (the default), the synaptic gain will remain unchanged.</span>

<span class="sd">        This does **not** change the synaptic gains of external drives.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_validate_type</span><span class="p">(</span><span class="n">copy</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="s2">&quot;copy&quot;</span><span class="p">)</span>

        <span class="n">net</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="bp">self</span>

        <span class="n">e_gids</span><span class="p">,</span> <span class="n">i_gids</span> <span class="o">=</span> <span class="n">_get_cell_index_by_synapse_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Define the connection types to modify</span>
        <span class="n">conn_types</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;e_e&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">e_e</span><span class="p">,</span> <span class="n">e_gids</span><span class="p">,</span> <span class="n">e_gids</span><span class="p">),</span>
            <span class="s2">&quot;e_i&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">e_i</span><span class="p">,</span> <span class="n">e_gids</span><span class="p">,</span> <span class="n">i_gids</span><span class="p">),</span>
            <span class="s2">&quot;i_e&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">i_e</span><span class="p">,</span> <span class="n">i_gids</span><span class="p">,</span> <span class="n">e_gids</span><span class="p">),</span>
            <span class="s2">&quot;i_i&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">i_i</span><span class="p">,</span> <span class="n">i_gids</span><span class="p">,</span> <span class="n">i_gids</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">conn_type</span><span class="p">,</span> <span class="p">(</span><span class="n">gain</span><span class="p">,</span> <span class="n">src_gids</span><span class="p">,</span> <span class="n">target_gids</span><span class="p">)</span> <span class="ow">in</span> <span class="n">conn_types</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">gain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">_validate_type</span><span class="p">(</span><span class="n">gain</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="n">conn_type</span><span class="p">,</span> <span class="s2">&quot;int or float&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gain</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Synaptic gains must be non-negative. Got </span><span class="si">{</span><span class="n">gain</span><span class="si">}</span><span class="s2"> for &#39;</span><span class="si">{</span><span class="n">conn_type</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                <span class="p">)</span>

            <span class="n">conn_indices</span> <span class="o">=</span> <span class="n">pick_connection</span><span class="p">(</span>
                <span class="n">net</span><span class="p">,</span> <span class="n">src_gids</span><span class="o">=</span><span class="n">src_gids</span><span class="p">,</span> <span class="n">target_gids</span><span class="o">=</span><span class="n">target_gids</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">conn_idx</span> <span class="ow">in</span> <span class="n">conn_indices</span><span class="p">:</span>
                <span class="n">net</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">conn_idx</span><span class="p">][</span><span class="s2">&quot;nc_dict&quot;</span><span class="p">][</span><span class="s2">&quot;gain&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gain</span>

        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">net</span></div>


<div class="viewcode-block" id="Network.get_global_synaptic_gains">
<a class="viewcode-back" href="../../generated/hnn_core.Network.html#hnn_core.Network.get_global_synaptic_gains">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_global_synaptic_gains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve gain values for different celltype connections in the Network.</span>

<span class="sd">        This function identifies excitatory and inhibitory cells in the Network</span>
<span class="sd">        and retrieves the `gain` value for each type of synaptic connection:</span>

<span class="sd">            - excitatory to excitatory (e_e)</span>
<span class="sd">            - excitatory to inhibitory (e_i)</span>
<span class="sd">            - inhibitory to excitatory (i_e)</span>
<span class="sd">            - inhibitory to inhibitory (i_i)</span>

<span class="sd">        The gain is assumed to be uniform across all instances of each connection type</span>
<span class="sd">        (for example, between AMPA and NMDA, and between `L2_pyramidal-&gt;L2_pyramidal` and</span>
<span class="sd">        `L2_pyramidal-&gt;L5_pyramidal`, etc.). Only the first connection&#39;s gain value is</span>
<span class="sd">        used for each type.</span>

<span class="sd">        This does **not** return the synaptic gains of external drives.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values : dict</span>
<span class="sd">            A dictionary with the connection types (&#39;e_e&#39;, &#39;e_i&#39;, &#39;i_e&#39;, &#39;i_i&#39;) as keys</span>
<span class="sd">            and their corresponding gain values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">e_gids</span><span class="p">,</span> <span class="n">i_gids</span> <span class="o">=</span> <span class="n">_get_cell_index_by_synapse_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Define the connection types and source/target cell indexes</span>
        <span class="n">conn_types</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;e_e&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">e_gids</span><span class="p">,</span> <span class="n">e_gids</span><span class="p">),</span>
            <span class="s2">&quot;e_i&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">e_gids</span><span class="p">,</span> <span class="n">i_gids</span><span class="p">),</span>
            <span class="s2">&quot;i_e&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">i_gids</span><span class="p">,</span> <span class="n">e_gids</span><span class="p">),</span>
            <span class="s2">&quot;i_i&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">i_gids</span><span class="p">,</span> <span class="n">i_gids</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="c1"># Retrieve the gain value for each connection type</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">conn_type</span><span class="p">,</span> <span class="p">(</span><span class="n">src_idxs</span><span class="p">,</span> <span class="n">target_idxs</span><span class="p">)</span> <span class="ow">in</span> <span class="n">conn_types</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">picks</span> <span class="o">=</span> <span class="n">pick_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_gids</span><span class="o">=</span><span class="n">src_idxs</span><span class="p">,</span> <span class="n">target_gids</span><span class="o">=</span><span class="n">target_idxs</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">picks</span><span class="p">:</span>
                <span class="c1"># Extract the gain from the first connection</span>
                <span class="n">values</span><span class="p">[</span><span class="n">conn_type</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">picks</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;nc_dict&quot;</span><span class="p">][</span><span class="s2">&quot;gain&quot;</span><span class="p">]</span>

        <span class="c1"># This writes the warning to stdout</span>
        <span class="n">_check_global_synaptic_gains_uniformity</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">values</span></div>


<div class="viewcode-block" id="Network.plot_cells">
<a class="viewcode-back" href="../../generated/hnn_core.Network.html#hnn_core.Network.plot_cells">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the cells using Network.pos_dict.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : instance of matplotlib Axes3D | None</span>
<span class="sd">            An axis object from matplotlib. If None,</span>
<span class="sd">            a new figure is created.</span>
<span class="sd">        show : bool</span>
<span class="sd">            If True, show the figure.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : instance of matplotlib Figure</span>
<span class="sd">            The matplotlib figure handle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">plot_cells</span><span class="p">(</span><span class="n">net</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">write_output</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">network_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">write_output</span><span class="o">=</span><span class="n">write_output</span><span class="p">)</span>

<div class="viewcode-block" id="Network.write_configuration">
<a class="viewcode-back" href="../../generated/hnn_core.Network.html#hnn_core.Network.write_configuration">[docs]</a>
    <span class="nd">@copy_doc</span><span class="p">(</span><span class="n">write_network_configuration</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_configuration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">write_network_configuration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span></div>


<div class="viewcode-block" id="Network.filter_cell_types">
<a class="viewcode-back" href="../../generated/hnn_core.Network.html#hnn_core.Network.filter_cell_types">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">filter_cell_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">metadata_filters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter cell types based on cell_metadata criteria</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filtered_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell_type_name</span><span class="p">,</span> <span class="n">cell_type_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_types</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">cell_metadata</span> <span class="o">=</span> <span class="n">cell_type_data</span><span class="p">[</span><span class="s2">&quot;cell_metadata&quot;</span><span class="p">]</span>
            <span class="n">match</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">metadata_filters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cell_metadata</span> <span class="ow">or</span> <span class="n">cell_metadata</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">value</span><span class="p">:</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                <span class="n">filtered_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell_type_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filtered_types</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_standardize_spike_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spike_data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Standardize spike data to internal format with &#39;times&#39; and &#39;gids&#39; keys.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spike_data : dict or list or str</span>
<span class="sd">            Input spike data in one of three formats:</span>
<span class="sd">            - Format 1: Dictionary where keys are source identifiers and values are</span>
<span class="sd">              lists of spike times in ms.</span>
<span class="sd">              Example: {&quot;NetA_L2_pyramidal_GID0&quot;: [10.2, 25.3], ...}</span>
<span class="sd">            - Format 2: List of (time, gid) tuples where time is the spike time in ms</span>
<span class="sd">              and gid identifies the source cell.</span>
<span class="sd">              Example: [(10.2, 0), (15.6, 1), (25.3, 0)]</span>
<span class="sd">            - Format 3: String path (or glob pattern) to spike files that can be loaded</span>
<span class="sd">              with hnn_core.read_spikes(), like &quot;path/to/spk_*.txt&quot;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        standardized_data : dict</span>
<span class="sd">            Dictionary with &#39;times&#39; and &#39;gids&#39; keys containing spike information</span>
<span class="sd">            in standardized internal format</span>
<span class="sd">        n_drive_cells : int</span>
<span class="sd">            Number of unique source cells detected</span>
<span class="sd">        source_to_gid_map : dict or None</span>
<span class="sd">            Mapping from source identifiers to sequential GIDs (for Format 1),</span>
<span class="sd">            or None (for Format 2 or Format 3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">source_to_gid_map</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spike_data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># Format 1: {source_id: [spike_times], ...}</span>
            <span class="n">source_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spike_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">n_drive_cells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_ids</span><span class="p">)</span>

            <span class="c1"># Transform to standardized format</span>
            <span class="n">all_times</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">all_gids</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Map source IDs to sequential gids</span>
            <span class="n">source_to_gid_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">src_id</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">src_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">source_ids</span><span class="p">)}</span>

            <span class="c1"># Collect all spike times and corresponding gids</span>
            <span class="k">for</span> <span class="n">src_id</span><span class="p">,</span> <span class="n">times</span> <span class="ow">in</span> <span class="n">spike_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">gid</span> <span class="o">=</span> <span class="n">source_to_gid_map</span><span class="p">[</span><span class="n">src_id</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                    <span class="n">all_times</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
                    <span class="n">all_gids</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">gid</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Spike times for source &#39;</span><span class="si">{</span><span class="n">src_id</span><span class="si">}</span><span class="s2">&#39; must be a list or array. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>

            <span class="n">standardized_data</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;times&quot;</span><span class="p">:</span> <span class="n">all_times</span><span class="p">,</span>
                <span class="s2">&quot;gids&quot;</span><span class="p">:</span> <span class="n">all_gids</span><span class="p">,</span>
            <span class="p">}</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spike_data</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">spike_data</span>
        <span class="p">):</span>
            <span class="c1"># Format 2: List of (time, gid) tuples</span>
            <span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">spike_data</span><span class="p">]</span>
            <span class="n">gids</span> <span class="o">=</span> <span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">spike_data</span><span class="p">]</span>

            <span class="c1"># Count unique drive cells</span>
            <span class="n">unique_gids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">gids</span><span class="p">)</span>
            <span class="n">n_drive_cells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_gids</span><span class="p">)</span>

            <span class="c1"># Ensure gids are sequential from 0 to n-1</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_gids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">unique_gids</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
                    <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">unique_gids</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_gids</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="p">):</span>
                    <span class="c1"># Reindex gids to be 0-based sequential integers</span>
                    <span class="n">gid_map</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="n">old_gid</span><span class="p">:</span> <span class="n">new_gid</span>
                        <span class="k">for</span> <span class="n">new_gid</span><span class="p">,</span> <span class="n">old_gid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">unique_gids</span><span class="p">))</span>
                    <span class="p">}</span>
                    <span class="n">new_gids</span> <span class="o">=</span> <span class="p">[</span><span class="n">gid_map</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span> <span class="k">for</span> <span class="n">gid</span> <span class="ow">in</span> <span class="n">gids</span><span class="p">]</span>
                    <span class="n">standardized_data</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;times&quot;</span><span class="p">:</span> <span class="n">times</span><span class="p">,</span>
                        <span class="s2">&quot;gids&quot;</span><span class="p">:</span> <span class="n">new_gids</span><span class="p">,</span>
                    <span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">standardized_data</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;times&quot;</span><span class="p">:</span> <span class="n">times</span><span class="p">,</span>
                        <span class="s2">&quot;gids&quot;</span><span class="p">:</span> <span class="n">gids</span><span class="p">,</span>
                    <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">standardized_data</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;times&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;gids&quot;</span><span class="p">:</span> <span class="p">[]}</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spike_data</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># Format 3: Handle string input as file path</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Read spike data from file</span>
                <span class="n">cell_response</span> <span class="o">=</span> <span class="n">read_spikes</span><span class="p">(</span><span class="n">spike_data</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Error loading spike data from file &#39;</span><span class="si">{</span><span class="n">spike_data</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="c1"># By default, use the first trial</span>
            <span class="n">trial_idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">trial_idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_response</span><span class="o">.</span><span class="n">spike_times</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Trial index </span><span class="si">{</span><span class="n">trial_idx</span><span class="si">}</span><span class="s2"> exceeds available trials &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">cell_response</span><span class="o">.</span><span class="n">spike_times</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Extract spike data from specified trial</span>
            <span class="n">spike_times</span> <span class="o">=</span> <span class="n">cell_response</span><span class="o">.</span><span class="n">spike_times</span><span class="p">[</span><span class="n">trial_idx</span><span class="p">]</span>
            <span class="n">spike_gids</span> <span class="o">=</span> <span class="n">cell_response</span><span class="o">.</span><span class="n">spike_gids</span><span class="p">[</span><span class="n">trial_idx</span><span class="p">]</span>
            <span class="n">spike_types</span> <span class="o">=</span> <span class="n">cell_response</span><span class="o">.</span><span class="n">spike_types</span><span class="p">[</span><span class="n">trial_idx</span><span class="p">]</span>

            <span class="c1"># Convert to dictionary format (Format 1)</span>
            <span class="n">spike_data_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">spike_gids</span><span class="p">,</span> <span class="n">spike_types</span><span class="p">):</span>
                <span class="n">src_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">_GID</span><span class="si">{</span><span class="n">g</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="n">src_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spike_data_dict</span><span class="p">:</span>
                    <span class="n">spike_data_dict</span><span class="p">[</span><span class="n">src_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">spike_data_dict</span><span class="p">[</span><span class="n">src_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="c1"># Recursively call this function with the dictionary data</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_spike_data</span><span class="p">(</span><span class="n">spike_data_dict</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;spike_data must be either:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;1. A dictionary {source_id: [spike_times], ...}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;2. A list of (time, gid) tuples</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;3. A file path string loadable with read_spikes()</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">spike_data</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">standardized_data</span><span class="p">,</span> <span class="n">n_drive_cells</span><span class="p">,</span> <span class="n">source_to_gid_map</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">_Connectivity</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class for containing the connectivity details of the network</span>

<span class="sd">    Class instances are essentially dictionaries, with the keys described below</span>
<span class="sd">    as &#39;attributes&#39;.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    src_type : str</span>
<span class="sd">        Cell type of source gids.</span>
<span class="sd">    target_type : str</span>
<span class="sd">        Cell type of target gids.</span>
<span class="sd">    gid_pairs : dict</span>
<span class="sd">        dict indexed by src gids with the format:</span>
<span class="sd">        {src_gid: [target_gids, ...], ...}</span>
<span class="sd">        where each src_gid indexes a list of all its targets.</span>
<span class="sd">    num_srcs : int</span>
<span class="sd">        Number of unique source gids.</span>
<span class="sd">    num_targets : int</span>
<span class="sd">        Number of unique target gids.</span>
<span class="sd">    src_gids : set of int</span>
<span class="sd">        Set of unique source gids in connection.</span>
<span class="sd">    target_gids : set of int</span>
<span class="sd">        Set of unique target gids in connection.</span>
<span class="sd">    loc : str</span>
<span class="sd">        Location of synapse on target cell. Must be</span>
<span class="sd">        &#39;proximal&#39;, &#39;distal&#39;, or &#39;soma&#39;. Note that inhibitory synapses</span>
<span class="sd">        (receptor=&#39;gabaa&#39; or &#39;gabab&#39;) of L2 pyramidal neurons are only</span>
<span class="sd">        valid loc=&#39;soma&#39;.</span>
<span class="sd">    receptor : str</span>
<span class="sd">        Synaptic receptor of connection. Must be one of:</span>
<span class="sd">        &#39;ampa&#39;, &#39;nmda&#39;, &#39;gabaa&#39;, or &#39;gabab&#39;.</span>
<span class="sd">    nc_dict : dict</span>
<span class="sd">        Dictionary containing details of synaptic connection.</span>
<span class="sd">        Elements include:</span>
<span class="sd">        A_weight : float</span>
<span class="sd">            Synaptic weight on target cell.</span>
<span class="sd">        A_delay : float</span>
<span class="sd">            Synaptic delay in ms.</span>
<span class="sd">        lamtha : float</span>
<span class="sd">            Space constant.</span>
<span class="sd">        threshold : float</span>
<span class="sd">            Firing threshold of cells for connection.</span>
<span class="sd">        gain : float</span>
<span class="sd">            Multiplicative factor for synaptic weight.</span>
<span class="sd">    probability : float</span>
<span class="sd">        Probability of connection between any src-target pair.</span>
<span class="sd">        Defaults to 1.0 producing an all-to-all pattern.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The len() of src_range or target_range will not match</span>
<span class="sd">    num_srcs and num_targets for probability &lt; 1.0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">entr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;src_type&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;target_type&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">entr</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">cell counts: </span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;num_srcs&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> srcs, &quot;</span>
        <span class="n">entr</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;num_targets&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> targets&quot;</span>
        <span class="n">entr</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">connection probability: </span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;probability&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
        <span class="n">entr</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">loc: &#39;</span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;loc&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;; receptor: &#39;</span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;receptor&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="n">entr</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">weight: </span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;nc_dict&#39;</span><span class="p">][</span><span class="s1">&#39;A_weight&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">; &quot;</span>
        <span class="n">entr</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;delay: </span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;nc_dict&#39;</span><span class="p">][</span><span class="s1">&#39;A_delay&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">; &quot;</span>
        <span class="n">entr</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;lamtha: </span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;nc_dict&#39;</span><span class="p">][</span><span class="s1">&#39;lamtha&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">entr</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;threshold: </span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;nc_dict&#39;</span><span class="p">][</span><span class="s1">&#39;threshold&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">entr</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;gain: </span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;nc_dict&#39;</span><span class="p">][</span><span class="s1">&#39;gain&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">entr</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> &quot;</span>

        <span class="k">return</span> <span class="n">entr</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_NetworkDrive</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class for containing the parameters of external drives</span>

<span class="sd">    Class instances are essentially dictionaries, with keys described below</span>
<span class="sd">    as &#39;attributes&#39;. For example, drive[&#39;events&#39;] contains the spike times of</span>
<span class="sd">    exogeneous inputs.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of drive (must be unique)</span>
<span class="sd">    location : str</span>
<span class="sd">        Target location of synapses (&#39;distal&#39; or &#39;proximal&#39;).</span>
<span class="sd">    type : str</span>
<span class="sd">        Examples: &#39;evoked&#39;, &#39;gaussian&#39;, &#39;poisson&#39;, &#39;bursty&#39;</span>
<span class="sd">    events : list of lists</span>
<span class="sd">        List of spike time lists. First index is of length n_trials. Second</span>
<span class="sd">        index is over the &#39;artificial&#39; cells associated with this drive.</span>
<span class="sd">    n_drive_cells : int</span>
<span class="sd">        The number of drive cells that contribute to this drive.</span>
<span class="sd">    cell_specific : bool</span>
<span class="sd">        Whether each cell has unique connection parameters (default: True)</span>
<span class="sd">        or all cells have common connections to a global (single) drive.</span>
<span class="sd">    event_seed : int</span>
<span class="sd">        Optional initial seed for random number generator used for event times.</span>
<span class="sd">        Each artificial drive cell has seed = event_seed + gid</span>
<span class="sd">    conn_seed : int</span>
<span class="sd">        Optional initial seed for random number generator.</span>
<span class="sd">        Used to randomly remove connections when probability &lt; 1.0.</span>
<span class="sd">    target_types : set or list of str</span>
<span class="sd">        Names of cell types targeted by this drive (must be subset of</span>
<span class="sd">        net.cell_types.keys()).</span>
<span class="sd">    dynamics : dict</span>
<span class="sd">        Parameters describing how the temporal dynamics of spike trains in the</span>
<span class="sd">        drive. The keys are specific to the type of drive (&#39;evoked&#39;, &#39;bursty&#39;,</span>
<span class="sd">        etc.). See the drive add-methods in Network for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">entr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&lt;External drive &#39;</span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;type&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">entr</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">drive class: </span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">entr</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">target location: </span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;location&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">entr</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">target cell types: </span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;target_types&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">entr</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">number of drive cells: </span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;n_drive_cells&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">entr</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">cell-specific: </span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;cell_specific&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">entr</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">dynamic parameters:&quot;</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;dynamics&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">entr</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s2">&quot;events&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">plurl</span> <span class="o">=</span> <span class="s2">&quot;s&quot;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s2">&quot;events&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="n">entr</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">event times instantiated for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;events&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2"> trial</span><span class="si">{</span><span class="n">plurl</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">entr</span> <span class="o">+=</span> <span class="s2">&quot;&gt;&quot;</span>
        <span class="k">return</span> <span class="n">entr</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_add_cell_type_bias</span><span class="p">(</span>
    <span class="n">network</span><span class="p">:</span> <span class="n">Network</span><span class="p">,</span>
    <span class="n">amplitude</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">cell_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">section</span><span class="o">=</span><span class="s2">&quot;soma&quot;</span><span class="p">,</span>
    <span class="n">bias_name</span><span class="o">=</span><span class="s2">&quot;tonic&quot;</span><span class="p">,</span>
    <span class="n">t_0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">t_stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add a tonic bias to a specific cell type in the network.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    network : Network</span>
<span class="sd">        The network to which the tonic bias is added.</span>
<span class="sd">    amplitude : float</span>
<span class="sd">        The amplitude of the tonic input (in nA) applied to the specified</span>
<span class="sd">        `cell_type`.</span>
<span class="sd">    cell_type : str</span>
<span class="sd">        The cell type to which the bias is applied.</span>
<span class="sd">    section : str, default &#39;soma&#39;</span>
<span class="sd">        The section of the cell where the bias is applied (e.g., &#39;soma&#39;,</span>
<span class="sd">        &#39;apical_tuft&#39;).</span>
<span class="sd">    bias_name : str, default &#39;tonic&#39;</span>
<span class="sd">        A name identifier for the bias configuration, allowing multiple biases</span>
<span class="sd">        to be applied.</span>
<span class="sd">    t_0 : float, default 0</span>
<span class="sd">        The start time of the tonic input in milliseconds.</span>
<span class="sd">    t_stop : float, optional</span>
<span class="sd">        The end time of the tonic input in milliseconds. If None, the bias</span>
<span class="sd">        continues until the end of the simulation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Validate cell_type value</span>
    <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">network</span><span class="o">.</span><span class="n">cell_types</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;cell_type must be one of &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">cell_types</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">bias_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">network</span><span class="o">.</span><span class="n">external_biases</span><span class="p">:</span>
        <span class="n">network</span><span class="o">.</span><span class="n">external_biases</span><span class="p">[</span><span class="n">bias_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="n">network</span><span class="o">.</span><span class="n">external_biases</span><span class="p">[</span><span class="n">bias_name</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Bias named </span><span class="si">{</span><span class="n">bias_name</span><span class="si">}</span><span class="s2"> already defined for </span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">cell_type_bias</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;amplitude&quot;</span><span class="p">:</span> <span class="n">amplitude</span><span class="p">,</span>
        <span class="s2">&quot;t0&quot;</span><span class="p">:</span> <span class="n">t_0</span><span class="p">,</span>
        <span class="s2">&quot;tstop&quot;</span><span class="p">:</span> <span class="n">t_stop</span><span class="p">,</span>
        <span class="s2">&quot;section&quot;</span><span class="p">:</span> <span class="n">section</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">sections</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">cell_types</span><span class="p">[</span><span class="n">cell_type</span><span class="p">][</span><span class="s2">&quot;cell_object&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sections</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="c1"># error when section is defined that doesn&#39;t exist.</span>
    <span class="k">if</span> <span class="n">section</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sections</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;section must be one of </span><span class="si">{</span><span class="n">sections</span><span class="si">}</span><span class="s2">. Got </span><span class="si">{</span><span class="n">section</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cell_type_bias</span><span class="p">[</span><span class="s2">&quot;section&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">section</span>

    <span class="n">network</span><span class="o">.</span><span class="n">external_biases</span><span class="p">[</span><span class="n">bias_name</span><span class="p">][</span><span class="n">cell_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_type_bias</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_check_global_synaptic_gains_uniformity</span><span class="p">(</span><span class="n">net</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check whether gain values are uniform within their type of connection.</span>

<span class="sd">    This function identifies excitatory and inhibitory cells in the Network</span>
<span class="sd">    and retrieves the gain value for each type of synaptic connection:</span>

<span class="sd">    - excitatory to excitatory (e_e)</span>
<span class="sd">    - excitatory to inhibitory (e_i)</span>
<span class="sd">    - inhibitory to excitatory (i_e)</span>
<span class="sd">    - inhibitory to inhibitory (i_i)</span>

<span class="sd">    The gain is then checked to see if it is uniform for all instances within each</span>
<span class="sd">    connection type (for example, between AMPA and NMDA, and between different</span>
<span class="sd">    connections like L2_pyramidal-&gt;L2_pyramidal and L2_pyramidal-&gt;L5_pyramidal). This</span>
<span class="sd">    does **not** check the synaptic gains of external drives.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output_indicator : bool</span>
<span class="sd">        A truth value indicating whether the synaptic gains are uniform within their</span>
<span class="sd">        connection type (True) or non-uniform (False).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">e_gids</span><span class="p">,</span> <span class="n">i_gids</span> <span class="o">=</span> <span class="n">_get_cell_index_by_synapse_type</span><span class="p">(</span><span class="n">net</span><span class="p">)</span>

    <span class="c1"># Define the connection types and source/target cell indexes</span>
    <span class="n">conn_types</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;e_e&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">e_gids</span><span class="p">,</span> <span class="n">e_gids</span><span class="p">),</span>
        <span class="s2">&quot;e_i&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">e_gids</span><span class="p">,</span> <span class="n">i_gids</span><span class="p">),</span>
        <span class="s2">&quot;i_e&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">i_gids</span><span class="p">,</span> <span class="n">e_gids</span><span class="p">),</span>
        <span class="s2">&quot;i_i&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">i_gids</span><span class="p">,</span> <span class="n">i_gids</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="n">output_indicator</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># Retrieve the gain value for each connection type</span>
    <span class="k">for</span> <span class="n">conn_type</span><span class="p">,</span> <span class="p">(</span><span class="n">src_idxs</span><span class="p">,</span> <span class="n">target_idxs</span><span class="p">)</span> <span class="ow">in</span> <span class="n">conn_types</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">picks</span> <span class="o">=</span> <span class="n">pick_connection</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">src_gids</span><span class="o">=</span><span class="n">src_idxs</span><span class="p">,</span> <span class="n">target_gids</span><span class="o">=</span><span class="n">target_idxs</span><span class="p">)</span>

        <span class="n">first_value</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">picks</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;nc_dict&quot;</span><span class="p">][</span><span class="s2">&quot;gain&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">other_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">picks</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
                    <span class="n">net</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">picks</span><span class="p">[</span><span class="n">other_idx</span><span class="p">]][</span><span class="s2">&quot;nc_dict&quot;</span><span class="p">][</span><span class="s2">&quot;gain&quot;</span><span class="p">],</span>
                    <span class="n">first_value</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">):</span>
                <span class="n">output_indicator</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="nb">print</span><span class="p">(</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    WARNING: Your imported Network uses custom synaptic gain values. Global synaptic gain values such as &quot;Excitatory-to-Inhibitory&quot; etc. will NOT be read or displayed properly. This is because Global synaptic gain values assume that initially, all gains are the same. If you continue to modify your Global synaptic gain values, double-check each connection&#39;s final synaptic gain value. To stop this warning, change your synaptic weights instead of your synaptic gains.</span>
<span class="sd">                    &quot;&quot;&quot;</span>
                <span class="p">)</span>
                <span class="k">break</span>

    <span class="k">return</span> <span class="n">output_indicator</span>
</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      Â© Copyright 2025, HNN Developers.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>