"""
==================================================
Optimize network parameters using custom loss functions
==================================================

This example demonstrates how to use custom loss functions with the HNN-core
optimizer. Custom loss functions are particularly useful for optimizing
steady-state oscillations generated by Poisson drives, where traditional
RMSE may not be appropriate.

We'll show three types of custom loss functions:
1. Spectral power loss - for matching power spectral densities
2. Phase coherence loss - for optimizing rhythmic coherence
3. Weighted RMSE loss - for emphasizing specific time periods
"""

# Authors: HNN-core developers

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import periodogram

import hnn_core
from hnn_core import Network, simulate_dipole
from hnn_core.optimization import (
    Optimizer,
    _spectral_power_loss,
    _phase_coherence_loss,
    _custom_rmse_with_weights,
)

###############################################################################
# First, let's create a simple network and add a Poisson drive to generate
# steady-state oscillations

# Create a small network
net = Network(add_drives_from_params=False)

# Add a Poisson drive to generate rhythmic activity
net.add_poisson_drive(
    name='poisson_drive',
    tstart=50.0,
    tstop=1000.0,
    rate_constant=10.0,
    location='proximal',
    weights_ampa={'L2_pyramidal': 0.01, 'L5_pyramidal': 0.01},
    weights_nmda={'L2_pyramidal': 0.01, 'L5_pyramidal': 0.01},
)

# Simulate to get baseline activity
tstop = 1000.0
baseline_dpls = simulate_dipole(net, tstop=tstop, n_trials=1)
baseline_dpl = baseline_dpls[0]

###############################################################################
# Example 1: Spectral Power Loss Function
# This loss function is useful when you want to match specific frequency
# content, particularly for steady-state oscillations.

def set_poisson_params(net, params):
    """Function to set Poisson drive parameters."""
    # Clear existing drives
    net.external_drives.clear()
    net.connectivity = []
    
    # Add Poisson drive with new parameters
    net.add_poisson_drive(
        name='poisson_drive',
        tstart=50.0,
        tstop=1000.0,
        rate_constant=params['rate_constant'],
        location='proximal',
        weights_ampa={
            'L2_pyramidal': params['weight_ampa_L2'],
            'L5_pyramidal': params['weight_ampa_L5']
        },
        weights_nmda={
            'L2_pyramidal': params['weight_nmda_L2'],
            'L5_pyramidal': params['weight_nmda_L5']
        },
    )

# Create target PSD (e.g., from experimental data)
# For this example, we'll create a synthetic target with peak at 10 Hz
freqs = np.linspace(1, 50, 100)
target_psd = np.exp(-0.5 * ((freqs - 10) / 2) ** 2)  # Gaussian peak at 10 Hz
target_psd += 0.1 * np.exp(-freqs / 10)  # Add 1/f background

# Define parameter constraints
constraints = {
    'rate_constant': (5.0, 20.0),
    'weight_ampa_L2': (0.001, 0.05),
    'weight_ampa_L5': (0.001, 0.05),
    'weight_nmda_L2': (0.001, 0.05),
    'weight_nmda_L5': (0.001, 0.05),
}

# Create optimizer with spectral power loss
optimizer_spectral = Optimizer(
    initial_net=net,
    tstop=tstop,
    constraints=constraints,
    set_params=set_poisson_params,
    obj_fun=_spectral_power_loss,
    max_iter=50,
)

# Fit using spectral power loss
print("Optimizing with spectral power loss...")
optimizer_spectral.fit(
    target_psd=target_psd,
    target_freqs=freqs,
    freq_range=(5, 20),  # Focus on 5-20 Hz range
    n_trials=1,
)

###############################################################################
# Example 2: Phase Coherence Loss Function
# This loss function optimizes for specific phase relationships, useful for
# rhythmic activity.

# Create optimizer with phase coherence loss
optimizer_coherence = Optimizer(
    initial_net=net,
    tstop=tstop,
    constraints=constraints,
    set_params=set_poisson_params,
    obj_fun=_phase_coherence_loss,
    max_iter=30,
)

# Fit using phase coherence loss
print("Optimizing with phase coherence loss...")
optimizer_coherence.fit(
    target_coherence=0.8,  # Target high coherence
    freq_band=(8, 12),     # Focus on alpha band
    n_trials=2,            # Need multiple trials for coherence
)

###############################################################################
# Example 3: Custom Weighted RMSE Loss Function
# This allows you to weight different time periods differently.

# Create a target dipole (for this example, we'll use the baseline)
target_dpl = baseline_dpl.copy()

# Create time weights that emphasize the middle portion of the simulation
times = target_dpl.times
time_weights = np.ones_like(times)
# Emphasize 200-800 ms period
middle_mask = (times >= 200) & (times <= 800)
time_weights[middle_mask] = 3.0  # 3x weight for middle period

# Create optimizer with weighted RMSE loss
optimizer_weighted = Optimizer(
    initial_net=net,
    tstop=tstop,
    constraints=constraints,
    set_params=set_poisson_params,
    obj_fun=_custom_rmse_with_weights,
    max_iter=30,
)

# Fit using weighted RMSE loss
print("Optimizing with weighted RMSE loss...")
optimizer_weighted.fit(
    target=target_dpl,
    time_weights=time_weights,
    n_trials=1,
)

###############################################################################
# Example 4: Completely Custom Loss Function
# You can also define your own loss function from scratch.

def my_custom_loss(
    initial_net,
    initial_params,
    set_params,
    predicted_params,
    update_params,
    obj_values,
    tstop,
    obj_fun_kwargs,
):
    """
    Custom loss function that combines multiple criteria.
    
    This example combines spectral power and amplitude criteria.
    """
    from hnn_core import simulate_dipole
    from scipy.signal import periodogram
    
    # Update parameters
    params = update_params(initial_params, predicted_params)
    
    # Simulate with new parameters
    new_net = initial_net.copy()
    set_params(new_net, params)
    dpls = simulate_dipole(new_net, tstop=tstop, n_trials=1)
    dpl = dpls[0]
    
    # Criterion 1: Spectral power in target band
    freqs, psd = periodogram(dpl.data['agg'], dpl.sfreq)
    target_band = (8, 12)  # Alpha band
    band_mask = (freqs >= target_band[0]) & (freqs <= target_band[1])
    band_power = np.sum(psd[band_mask])
    total_power = np.sum(psd)
    relative_power = band_power / total_power
    
    # Criterion 2: Signal amplitude should be within reasonable range
    signal_std = np.std(dpl.data['agg'])
    target_std = obj_fun_kwargs.get('target_std', 50.0)
    amplitude_error = abs(signal_std - target_std) / target_std
    
    # Combine criteria
    obj = -relative_power + 0.5 * amplitude_error  # Minimize this
    obj_values.append(obj)
    
    return obj

# Create optimizer with completely custom loss
optimizer_custom = Optimizer(
    initial_net=net,
    tstop=tstop,
    constraints=constraints,
    set_params=set_poisson_params,
    obj_fun=my_custom_loss,
    max_iter=30,
)

# Fit using custom loss
print("Optimizing with completely custom loss...")
optimizer_custom.fit(target_std=30.0)

###############################################################################
# Plot convergence for all optimizers

fig, axes = plt.subplots(2, 2, figsize=(12, 10))
axes = axes.flatten()

optimizers = [
    (optimizer_spectral, "Spectral Power Loss"),
    (optimizer_coherence, "Phase Coherence Loss"),
    (optimizer_weighted, "Weighted RMSE Loss"),
    (optimizer_custom, "Custom Combined Loss"),
]

for i, (opt, title) in enumerate(optimizers):
    opt.plot_convergence(ax=axes[i], show=False)
    axes[i].set_title(title)

plt.tight_layout()
plt.show()

###############################################################################
# Compare the optimized networks by simulating dipoles

fig, axes = plt.subplots(2, 2, figsize=(12, 10))
axes = axes.flatten()

for i, (opt, title) in enumerate(optimizers):
    # Simulate with optimized network
    opt_dpls = simulate_dipole(opt.net_, tstop=tstop, n_trials=1)
    opt_dpl = opt_dpls[0]
    
    # Plot time series
    axes[i].plot(opt_dpl.times, opt_dpl.data['agg'], 'b-', label='Optimized')
    axes[i].plot(baseline_dpl.times, baseline_dpl.data['agg'], 'r--', 
                 alpha=0.7, label='Baseline')
    axes[i].set_title(f'{title}\nFinal obj: {opt.obj_[-1]:.4f}')
    axes[i].set_xlabel('Time (ms)')
    axes[i].set_ylabel('Dipole (nAm)')
    axes[i].legend()

plt.tight_layout()
plt.show()

print("Custom loss function optimization complete!")
print("\nKey benefits of custom loss functions:")
print("1. Spectral power loss: Better for steady-state oscillations")
print("2. Phase coherence loss: Optimizes rhythmic consistency")
print("3. Weighted RMSE: Emphasizes specific time periods")
print("4. Custom combined: Allows multiple optimization criteria")